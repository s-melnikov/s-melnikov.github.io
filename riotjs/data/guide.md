
title: Руководство
subtitle: Разработка клиентского приложения используя Riot
date: Thu Feb 26 2015 18:37:17

====

# Пример пользовательского тега

Пользоваьельские теги в Riot являются строительными блоками для построения пользовательского интерфейса. Они являются "отображением" вашего приложения ("view"). Давайте начнем знакомство с особенностями Riot на примере расширенного TODO приложения:

```lang-jsx
<todo>

  <h3>{ opts.title }</h3>

  <ul>
    <li each={ items }>
      <label class={ completed: done }>
        <input type="checkbox" checked={ done } onclick={ parent.toggle }> { title }
      </label>
    </li>
  </ul>

  <form onsubmit={ add }>
    <input name="input" onkeyup={ edit }>
    <button disabled={ !text }>Add #{ items.length + 1 }</button>
  </form>

  <script>
    this.disabled = true

    this.items = opts.items

    edit(e) {
      this.text = e.target.value
    }

    add(e) {
      if (this.text) {
        this.items.push({ title: this.text })
        this.text = this.input.value = ''
      }
    }

    toggle(e) {
      var item = e.item
      item.done = !item.done
      return true
    }
  </script>

</todo>
```

Пользовательские теги должны быть [скомпилированы](#compiler) в JavaScript.

Смотрите [живой пример](http://muut.github.io/riotjs/demo/), [исходный код](https://github.com/muut/riotjs/tree/gh-pages/demo) или [скачайте zip-архив](https://github.com/muut/riotjs/archive/gh-pages.zip).

### Синтаксис тегов

Теги Riot это комбинация отображения (HTML) и логики (JavaScript). Основные правила:

* Сначала идет определение HTML, потом описание логики заключенное в тег `script`.
* Без тега скрипт определение JavaScript должно начинаться после последнего тега HTML. 
* Тег может быть пустым, в нем может быть только HTML или только JavaScript.
* Кавычки по желанию: `<foo bar={ baz }>` преобразуется в `<foo bar="{ baz }">`.
* Поддерживается ES6 синтаксис: `methodName()` преобразуется в `this.methodName = function()` и `this` всегда указывает на текущий экземпляр тега.
* Возможна сокращенная запись имен классов: `class={ completed: done }` преобразуется в `class="completed"` если значение `done` является true.
* Булевые атрибуты (checked, selected и т.д.) игнорируются в случае если значение возвращает `false`: `<input checked={ undefined }>` преобразуется в `<input>`.
* Все имена атрибутов должны быть в нижнем регистре.
* Поддерживаются одинарные закрытые теги: `<div/>` приравнивается к `<div></div>`. Такие "открытые теги" как `<br>`, `<hr>`, `<img>` или `<input>` не нуждаются в закрытии.
* В тоже время все пользовательские теги должны быть закрытыми.
* Стандартные HTML теги (`label`, `table`, `a` etc..) также могут быть настроены (кастомизированы), но лучше этого не делать.

Определение тега должно всегда начинаться с начала строки:

```lang-jsx
<!-- работает -->
<my-tag>

</my-tag>

  <!-- не работает, потому что есть отступ -->
  <my-tag>

  </my-tag>
```

### Без тега `script`

Вы также можете описывать логику без использования тега `script`:

```lang-jsx
<todo>

  <!-- layout -->
  <h3>{ opts.title }</h3>

  // logic comes here
  this.items = [1, 2, 3]

</todo>
```

В этом случае логика начинается после последнего HTML тега. Этот "открытый синтаксис" наиболее часто используется в примерах на этом сайте.

### Препроцессоры

Вы можете указывать тип препроцессора при помощи атрибута `type`. Пример:

```lang-jsx
<script type="coffeescript">
  # логика приложения
</script>
```

На данный момент доступны следующие типы: "coffeescript", "typescript", "es6" и "none". Вы также можете указать префикс "text/", к примеру "text/coffeescript".

Для более подробного описания читайте раздел [препроцессоры](#compiler/preproczessory)

### Стилизация тега

Вы можете вставить элемент `style` внутрь определения тега. Riot.js автоматически переносит их в тег `<head>`.

```lang-markup
<todo>

  <!-- layout -->
  <h3>{ opts.title }</h3>

  <style>
    todo { display: block }
    todo h3 { font-size: 120% }
    /* остальные стили */
  </style>

</todo>
```

Это происходит только один раз, вне зависимотси сколько раз тег проинициализируется.

### Контекстное CSS

[Контекстное CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/:scope) теперь доступно. Этот пример равносилен придыдущему:

```html
<todo>

  <!-- layout -->
  <h3>{ opts.title }</h3>

  <style scoped>
    :scope { display: block }
    h3 { font-size: 120% }
    /* остальные стили */
  </style>

</todo>
``` 

## Связывание

После того как тег создан вы можете монтировать его на странице следующим образом:

```lang-markup
<body>

  <!-- установите свой тег в любом месте внутри body -->
  <todo></todo>

  <!-- подключите riot.js -->
  <script src="riot.min.js"></script>

  <!-- подключите файл с тегом -->
  <script src="todo.js" type="riot/tag"></script>

  <!-- установите тег -->
  <script>riot.mount('todo')</script>

</body>
```

Пользовательский тег внутри `body` страницы должен быть закрытым: `<todo></todo>`, самозакрывающиеся теги типа `<todo/>` не поддерживаются.

Несколько примеров исмользования метода `mount()`:

```lang-javascript
// установка всех пользовательских тегов на странице
riot.mount('*')

// установить элемент с определенным id
riot.mount('#my-element')

// установить выбранные элементы
riot.mount('todo, forum, comments')
```

На странице может быть несколько экземпляров одного и того же тега.

### Опции

Вторым аргументом в методе `mount` вы можете передать опции для вашего тега.

```lang-jsx
<script>
riot.mount('todo', { title: 'My TODO app', items: [ ... ] })
</script>
```

Передаваемые опции могут быть чем угодно, начиная от простого объекта и заканчивая полным API приложения. Или это может быть Flux store. Все завист от архитектуры вашего приложения.

Внутри тега ссылка на опции представлена в виде преременной `opts`. Пример:

```lang-jsx
<my-tag>

  <!-- Опции в HTML -->
  <h3>{ opts.title }</h3>

  // Опции в JavaScript
  var title = opts.title

</my-tag>
```

### Жизненый цикл тега

Тег создается в следующей последовательности:

1. Строится тег
2. Выполняется JavaScript логика тега
3. HTML выражения подсчитываются и вызывается событие "update"
4. Тег устанавливается на страницу и вызывается событие "mount"

После того как тег установлен на страницу выражения пересчитываются в следующих случаях:

1. Автоматически когда вызывается обработчик события. К примеру, метод `toggle` в примере выше.
2. Когда вызывается `this.update()` внутри экземпляра тега.
2. Когда вызывается `this.update()` в любом родительском теге. Событие обновления всегда распростроняется от родительского к дочернему элементу.
3. Когда вызывается `riot.update()`, который обновляет глобально все выражения на странице.

Событие "update" вызывается каждый раз когда тег обновляется.

Так как значения высчитываются перед тем как установить тег, не должно быть таких сюрпризов, как неудачное обращение к `<img src={ src }>`.

### Прослушивание событий жизненного цикла

Вы можете следить за любым циклом событий внутри тега следующим образом:

```lang-javascript
<todo>

  this.on('mount', function() {
    // вызывается сразу после установки тега
  })

  this.on('update', function() {
    // позволяет пересчитать данные 
    // контекстные данные перед обновлением
  })

  this.on('unmount', function() {
    // вызывается после удаления тега
  })

  // следить за всеми перечисленными событиями
  this.on('mount update unmount', function(eventName) {
    console.info(eventName)
  })

</todo>
```

У вас может быть несколько слушателей для одного события. Для более подробного описания событий смотрите раздаел [наблюдение](#api/nablyudenie).

## Выражения

В HTML можно использовать выражения заключеные в фигурные скобки:

```lang-javascript
{ /* ваше_выражение будет здесь */ }
```

Выоажения могкт быть установлены в атрибуты тегов или как вложеный текстовый узел:

```lang-markup
<h3 id={ /* выражение_фттрибута */ }>
  { /* вложенное_выражение */ }
</h3>
```

Выражения yf 100% JavaScript. Пару примеров:

```lang-javascript
{ title || 'Без названия' }
{ results ? 'готово' : 'загружается' }
{ new Date() }
{ message.length > 140 && 'Слишком длинное сообщение' }
{ Math.round(rating) }
```

Цель в том чтобы ваши выражения были простыми и короткими что позволяет оставаться вашему HTML простым и понятным. Если ваши выражения начнут расти и усложнятся, тогда стоит подумать о том, чтобы перенести вашу логику в событие "update". Для примера:

```lang-jsx
<my-tag>

  <!-- значение `val` подсчитывается ниже.. -->
  <p>{ val }</p>

  // .. вызывается при каждом обновлении
  this.on('update', function() {
    this.val = some / complex * expression ^ here
  })
</my-tag>
```

### Булевые атрибуты

Булевые атрибуты (checked, selected, ...) игнорируются если выражение возвращает ложное значение:

`<input checked={ null }>` превратится в `<input>`.

W3C утверждает, что булевые свойства преобретают значение true если они представлены, даже если у него в значении пусто или стоит `false`.

Следущее выражение не сработает:

```lang-markup
<input type="checkbox" { true ? 'checked' : ''}>
```

так как валидны только выражения в атрибутах и вложеные текстовые выражения. Riot определяет 44 различных булевых атрибута для тегов.

### Сокращения для классов

В Riot есть специальный синтаксис длс CSS классов. Пример:

```lang-javascript
<p class={ foo: true, bar: 0, baz: new Date(), zorro: 'a value' }></p>
```

будет преобразовано в "foo baz zorro". Имена свойств объекта которые значение которых приводится к `true` добавляются к списку классов. Конечно же вы можете использовать этот синтаксис и в других случаях, отличных от имен классов, если вы найдете подходящий вариант для его использования.

### Вывод скобок

Вы можете вывести любое выражение не вычисляя его если вы его заэкранируете фигурные скобки:

`\\{ это выражение не просчитывается \\}` выведет `{ и это выражение не просчитывается }`

### Пользовательские скобки

Вы можете свободно изменять тип скобок на те, которые вам удобнее использовать. Пример:

```lang-javascript
riot.settings.brackets = '${ }'
riot.settings.brackets = '{{ }}'
```

Открывающие и закрывающие скобки разделяются пробелом.

Это будет удобно если вы, к примеру, используете препроцессоры.

### Прочее

Выражения находящиеся внутри тега `style` игнорируются.

### Отрисовка незаэкранированного HTML

Riot выражения могут выводить только текстовые значения без HTML форматирования. Однако вы можете использовать тег для вывода HTML. Пример:

```lang-jsx
<raw>
  <span></span>

  this.root.innerHTML = opts.content
</raw>
```

После того как тег будет определен вы можете использовать его внутри других тегов. Пример:

```lang-jsx
<my-tag>
  <p>Here is some raw content: <raw content="{ html }"/> </p>

  this.html = 'Hello, <strong>world!</strong>'
</my-tag>
```

[Демо на jsfiddle](http://jsfiddle.net/23g73yvx/)

<span class="tag red">ВНИМАНИЕ</span> это может дать возможность пользователю совершить XSS атаку. Никогда не загружайте данные из непроверенных источников.

## Вложеные теги

Давайте объявим родительский тег `<account>`и вложеный в него тег `<subscription>`:

```lang-jsx
<account>
  <subscription  plan={ opts.plan } show_details="true" />
</account>


<subscription>
  <h3>{ opts.plan.name }</h3>

  // Получаем данные из опций
  var plan = opts.plan,
    show_details = opts.show_details

  // доступ к родительскому тегу
  var parent = this.parent

</subscription>
```

После монтируем тег `account` на странице с опцией `plan`:

```lang-jsx
<body>
  <account></account>
</body>

<script>
riot.mount('account', { plan: { name: 'small', term: 'monthly' } })
</script>
```

Опции родительского тега передаются в методе `riot.mount`, а опции дочерних тегов передаются в атрибут тега.

<span class="label red">ВАЖНО</span> Вложенные теги всегда объявляются внутри родительского пользовательского тега. Они не инициализируется если объявляются на странице.

### Вложенный HTML

Это пример пользовательского тега на странице с вложеным HTML:

```lang-markup
<body>
  <my-tag>
    <h3>Hello world!</h3>
  </my-tag>
</body>

<script>
riot.mount('my-tag')
</script>
```

Мы можем получить доступ к внутреннему HTML простым способом используя для этого дополнительный пользовательский тег:

```lang-markup
<my-tag>
  <p>Some tag specific markup</p>
  <!-- здесь будет внутренний HTML определенный на странице -->
  <inner-html/>
</my-tag>
```

Исходный код тега `inner-html`:

```lang-jsx
<inner-html>
  var p = this.parent.root
  while (p.firstChild) this.root.appendChild(p.firstChild)
</inner-html>
```

Тег такого типа в дальнейшем будет внесен в набор встроеных в Riot тегов.

## Именованые элементы

Элементы с `name` или `id` атрибутом автоматически привязываются к контексту тега, благодаря этому вы получаете доступ к ним через JavaScript:

```lang-jsx
<login>
  <form id="login" onsubmit={ submit }>
    <input name="username">
    <input name="password">
    <button name="submit">
  </form>
  
  // получаем значение инпутов выше
  var form = this.login,
    username = this.username.value,
    password = this.password.value,
    button = this.submit

</login>
```

И конечно же эти элементы можно передать в HTML уже привычным способом: `<div>{ username.value }</div>`

## Обработчики событий

Функции, которые имеют дело с событиями DOM называются "обработчики событий". Обработчики событий объявляются следующим образом:

```lang-jsx
<login>
  <form onsubmit={ submit }>

  </form>

  // этот метод вызовется как только 
  // нажмется кнопка submit формы
  submit(e) {

  }
</login>
```

Атрибуты начинающиеся с "on" (`onclick`, `onsubmit`, `oninput` и т.д.) принимают значение функции которая вызывается когда это событие происходит. Эта функция также может определяться динамически при помощи выражения. Для примера:

```lang-markup
<form onsubmit={ condition ? method_a : method_b }>
```

Внутри функции переменная `this` ссылается на экземпляр текущего тега. Позле вызова обработчика автоматически вызывается метод `this.update()` который в свою очередь отображает все возможные изменения в UI. Обработчик события который вызывается по умолчанию *автоматически отменяется*. Это значит, что каждый раз вызывается `e.preventDefault()`, потому что это то, что обычно делают (или забывают сделать). Вы можете позволить браузеру выполнить действия по-умолчанию вернув в обработчике `true`.

Для примера, это обработчик события `submit` всетаки отправит данные формы на сервер:

```lang-jsx
submit() {
  return true
}
```

### Объект события

Обработчик событий получает стандартный объект события в первом аргументе. Следующие свойства объекта события нормализуются для кроссбраузерной работы:

* `e.currentTarget` ссылается на объект, на который повешан обработчик события
* `e.target` элемент, в котором произошло событие. Это не обязательно тот же элемент, что и `currentTarget`. 
* `e.which` это код клавиши события клавиатуры (такие события как `keypress`, `keyup`, и т.д.).
* `e.item` это текущий элемент в цикле. Для более подробного описания смотрите [циклы](#guide/czikly).

## Условные выражения

Условные выражения дают вам возможность спрятать / показать элемент на основе условия. Пример:

```lang-markup
<div if={ is_premium }>
  <p>Только для премиум пользователей</p>
</div>
```

Опять же, выражение может быть просто простым свойством или JavaScript выражением. Доступны следущие специальные атрибуты:

- `show` – показать элемент используя `style="display: ''"` если значение приводится к true
- `hide` – спрятать элемент используя `style="display: none"` если значение приводится к true
- `if` – добавить (если true) или удалить (если false) элемент из документа

Используйте оператор сравнения `==`, не `===`. Для примера: `'a string' == true`.

<small>В настоящее время `if` оператор реализован с помощью CSS свойства display.</small>

## Циклы

Циклы реализуются при помощи атрибута `each` следующим образом:

```lang-jsx
<todo>
  <ul>
    <li each={ items } class={ completed: done }>
      <input type="checkbox" checked={ done }> { title }
    </li>
  </ul>

  this.items = [
    { title: 'First item', done: true },
    { title: 'Second item' },
    { title: 'Third item' }
  ]
</todo>
```

Элементы с атрибутом `each` будут повторены для всех элементов массива. Новые элементы будут автоматически добавлены / созданы если массив элементов будет изменен, к примеру при помощи `push()`, `slice()` или `splice` методов.

### Контекст

Для каждого элемента создается новый контекст и доступ к родительскому контексту осуществляется через переменную `parent`. Для примера: 

```lang-jsx
<todo>
  <div each={ items }>
    <h3>{ title }</h3>
    <a onclick={ parent.remove }>Remove</a>
  </div>

  this.items = [ { title: 'First' }, { title: 'Second' } ]

  remove(event) {

  }
</todo>
```

В элементе цикла все атрибуты, кроме `each` принадлежат дочернему контексту, так что к `title` мы имеем доступ непосредственно, а `remove` требует префикса `parent.` так как метод не является свойством элемента цикла.

Элементы в цикле могут быть [экземпляром тега](#api/ekzemplyar_tega). Riot не изменяет исходные элементы цикла, поэтому никаких посторонних свойств в них нет.

### Обработчики событий в элементах цикла

Обработчик события имеют доступ к индивидуальному элементу коллекции через `event.item`. 
Event handlers can access individual items in a collection with `event.item`. Давайте теперь реализуем функцию `remove`:

```lang-jsx
<todo>
  <div each={ items }>
    <h3>{ title }</h3>
    <a onclick={ parent.remove }>Remove</a>
  </div>

  this.items = [ { title: 'First' }, { title: 'Second' } ]

  remove(event) {

    // элемент цикла
    var item = event.item

    // индекс в коллекции
    var index = this.items.indexOf(item)

    // удаление из коллекции
    this.items.splice(index, 1)
  }
</todo>
```

После того как отработает обработчик события текущий экземпляр тега обновляется при помощи `this.update()` что будет причиной также пересчитать все элементы цикла. Родительский тег определяет что элемент был удален из коллекции и удаляет соотыетствующий DOM узел из документа.

### Вывод в цикле пользовательских тегов

Пользовательские теги также могут быть выведены в цикле. Пример:

```lang-markup
<todo-item each="{ items }" data="{ this }"></todo-item>
```

Доступ к текущему елементу цикла можно получить через переменную `this` если вы хотите использовать его для передачи каких либо опций в тег цикла.

### Массив простых элементов

Элементы массива не обязательно должны быть объектом, они так же могут быть строкой или числом. В этом случае вы должны использовать `{ name, i in items }` конструкцию следующим образом:

```lang-jsx
<my-tag>
  <p each="{ name, i in arr }">{ i }: { name }</p>

  this.arr = [ true, 110, Math.random(), 'fourth']
</my-tag>
```

В нашем случае `name` это имя значение элемента массива и `i` - порядковый номер элемента массива. эти переменные могут называться как угодно, в зависимости от ситуации.

### Вывод объекта в цикле

Простые объекты тоже могут быть выведены в цикле. Пример:

```lang-jsx
<my-tag>
  <p each="{ name, value in obj }">{ name } = { value }</p>

  this.obj = {
    key1: 'value1',
    key2: 1110.8900,
    key3: Math.random()
  }
</my-tag>
```

Вывод объекта в цикле не рекомендуется, так как внутренняя реализация определения изменений объектов в Riot базируется на `JSON.stringify`. Объект *изучается* (сравниваются строковые представления предыдущего и текущего состояния объекта) и если он изменен весь цикл перерисовывается. И это может занимать много времени. Обычные массивы обрабатываются намного быстрее и только в случае изменений перерисовывается цикл.

# Архитектура приложения

## Инструменты вместо правил

Riot постовляется в комплекте с пользовательскими тегами, диспетчером событий (observable) и маршрутизатором. Мы считаем что это фундаментальные строительные блоки для клиентского приложения:

1. Пользовательские теги для построения интерфейса, 
2. События для модульности и
3. Маршрутизатор для слежения за URl и поддержки кнопки "назад".

Riot старается не навязывать строгих правил, а скорее дать базовые инструменты которыми вы можете творчески воспользоваться. Этот гибкий подход позволяет использовать большие архитектурные решения для разработчика.

Мы также считаем что эти основеые блоки должны быть небольшими. С точки зрения размеров файлов и API. Елементарные вещи должны быть простыми. Это облегчаен ваш разум.

## Наблюдения за объектами

Наблюдатель - это основной инструмент для отправки и получения событий. Этот простой паттерн изолирует модули не формируя при этом зависимостей или "связей". Используя события можно разбивать большие програмы на более мелкие и простые составные части. Модули могут быть добывлены / удалены / изменены не затрагивая другие части приложения.

Обычной практикой является разделение приложения на единичное ядро и множество расширений. Ядро возбуждает событие каждый раз, когда происходит что то значимое: добавляется новый элемент, существующий элемент удаляется или что то загрузилось с сервера.

При использовании наблюдателя расширения могут слушать эти события и реагировать на них. Они расширяют ядро и при этом ядро не знает о них. Этот паттерн называется "слабая связь".

Эти расширения могут быть пользовательскими тегами (UI компоненты) или не UI модулями.

Когда ядро приложения и его события тщательно спроектированы, члены команды могут дальше разрабатывать систему самостоятельно не мешая друг другу.

[API наблюдателя](#api/nablyudenie)

## Маршрутизация

Riot маршрутизатор является общим инструментом для работы с URL и кнопкой "назад". Это одно из самых минималистичных реализаций маршрутизатора которую вы можете найти и она работает во всех браузер начиная с IE8. Он может делать следующее:

1. Изменять хеш URL'а
2. Уведомлять о смене хеша и
3. Получить текущий хеш

Логику, отвечающую за маршруты, вы можете разместить где угодно в вашем приложении, в пользовательском теге или в каком либо не UI модуле. Некоторые фреймворки делают маршрутизатор центральноым элементом которы отвечает за работу остальных частей приложения. Некоторые придерживаются более мягкого подхода где URL, как события клавиш, не влияют на общую архитектуру.

Каждое браузерные приложения нуждаются в маршрутизации, так как URL являься одним из главных элементов страницы.

[API маршрутизатора](#api/marshrutizator)

## Модульность

Riot теги создают отображения ваших приложений. В модульных приложениях эти теги не должны знать про всех других и должны быть изолированы. В идеале вы можете использовать одни и те же теги в разных проектах несмотря на внешнюю HTML верстку.

Если два тега знают друг о друге то они становятся зависимыми и между ними устанавливается "тесная связь". Эти теги не могут быть свободно перемещены, удалены или изменены не нарушая систему.

Идея слабой связанности заключается в том, что теги слушают события вместо того, что бы обращаться друг к другу напрямую. Вам нужна система публикация/подписка построенная на основе riot.observable или что-то аналогичное.

Эта система событий может варьироваться от простого API до большого архитектурного решения, такого как Facebook Flux.

### Пример структуры приложения на Riot

Это простой пример структуры Riot приложения для авторизации пользователей:

```lang-jsx
// Login API
var auth = riot.observable()

auth.login = function(params) {
  $.get('/api', params, function(json) {
    auth.trigger('login', json)
  })
}

<!-- отображение  -->
<login>
  <form onsubmit="{ login }">
    <input name="username" type="text" placeholder="username">
    <input name="password" type="password" placeholder="password">
  </form>

  login() {
    opts.login({
      username: this.username.value,
      password: this.password.value
    })
  }

  // любой тег в системе может 
  // слушать событие авторизации
  opts.on('login', function() {
    $(body).addClass('logged')
  })
</login>
```

И после монтируем приложение

```lank-markup
<body>
  <login></login>
  <script>riot.mount('login', auth)</script>
</body>
```

В примере выше остальные теги в системе не нуждаются в том, что бы знать о каждом другом теге, они просто могут слушать событие "login" и делать то, что им заблагорассудится.

Наблюдение является классическим подходом в построении несвязанного (модульного) приложения.