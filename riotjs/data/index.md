
title: Почему Riot?
subtitle: И зачем нам нужна новая UI библиотека
date: Tue Feb 24 2015 17:30:25

====

## 1. Пользовательские теги

Пользовательские теги Riot работают во всех современных браузерах начиная с IE8.

```lang-jsx
<todo>

  <!-- layout -->
  <h3>{ opts.title }</h3>

  <ul>
    <li each={ item, i in items }>{ item }</li>
  </ul>

  <form onsubmit={ add }>
    <input>
    <button>Add #{ items.length + 1 }</button>
  </form>

  <!-- logic -->
  <script>
    this.items = []

    add(e) {
      var input = e.target[0]
      this.items.push(input.value)
      input.value = ''
    }
  </script>

</todo>
```

Пользовательские теги собираются из HTML и JavaScript и образуют многократно используемые компоненты. Это работает как React + Polymer, но при этом занимает всего 2.5KB.

### Читаемость кода

Пользовательские теги дают возможность строить сложные HTML отображения. Пример того, как будет выглядеть ваше приложение:

```lang-jsx
<body>

  <h1>Acme community</h1>

  <forum-header/>

  <forum-content>
    <forum-threads/>
    <forum-sidebar/>
  </forum-content>

  <forum-footer/>

  <script>riot.mount('*', { api: forum_api })</script>
</body>
```

HTML синтаксис по факту является языком веба и специально разработан для построения пользовательского интерфейса. Его синтаксис понятен, вложеность является неотъемлемой частью языка, атрибуты предлагают простой способ определить опции для пользовательских тегов.

<span class="label">Внимание</span> теги должны быть [скомпилированы](#compiler) в JavaScript прежде чем выполняться в браузере.

### Виртуальный DOM

* Минимально возможное колличество обновления и перекомпоновки DOM.
* Одностороний поток данных: событие обновления и удаления распростроняются от родительского тега к дочернему.
* Все выражения предварительно компилируются и кэшируются для лучшей производительности.
* Доступу к жизненому циклу события для большего контроля.

### Близко к стандартам

* Без проприетарной системы событий.
* Нормализация событий для IE8.
* DOM после рендера доступен для манипуляций сторонними инструментами.
* Без дополнительных корневых HTML элементов или `data-` атрибутов.
* Отлично совместим с jQuery.

### Используйте ваши любимые инструменты

* Создавайте теги используя CoffeeScript, Jade, Typescript, ES6 или любой другой [препроцессор](#compiler/preproczessory) по вашему желанию.
* Интегрируйте используя NPM, CommonJS, AMD, Bower или Component.
* Разрабатывайте используя [Gulp](https://github.com/e-jigsaw/gulp-riot), [Grunt](https://github.com/ariesjia/grunt-riot) или [Browserify](https://github.com/jhthorsen/riotify) плагины.

## 2. Простота и минимализм

Минимализм выделяет Riot среди остальных:

### 1. Приятный синтаксис

Одна из целей в проектировании была предоставить мощный синтаксис тегов с минимальной шаблонностью:

* Удобные сокращения: `class={ enabled: is_enabled, hidden: hasErrors() }`.
* Без мозголомных конструкций, таких как `getInitialState` или `shouldComponentUpdate`.
* Интерполяция: `Add #{ items.length + 1 }` или `class="item { selected: flag }"`.
* Возможность использования тега `script` для описания логики.
* Компактный ES6 синтаксис.

### 2. Минимальное время обучения

Riot имеет в 10 раз, а в некоторых случаях даже в 100 раз меньше методов API, чем у других.

1. Прост в обучении. Меньше материалов и туториалов требуется для ознакомления.
2. Меньше проприетарных вещей и больше стандартных вещей.

### 3. Крошечный размер

<small><em>react.min.js</em> – 127Kb</small>
<span class="bar red"></span>

<small><em>polymer.min.js</em> – 120Kb</small>
<span class="bar red" style="width: 94%"></span>

<small><em>riot.min.js</em> – 6.7Kb</small>
<span class="bar blue" style="width: 4.8%"></span>

1. Меньше ошибок.
2. Быстрее в анализе и загрузке.
3. Встраиваемый. Библиотека меньше чем само тприложение.
4. Проще в поддержке. Вам не нужна большая команда для поддержки Riot.

### 4. Маленький но самодостаточный

Riot имеет все необходимые состовляющие для построения современных клиентских приложений:

* "Реактивные" отображения для построения пользовательского интерфейса.
* Библиотка для работы с событиями позволяет постороить API с изолироваными модулями.
* Маршрутизатор для работы с URL и поддержкой кнопки "назад".

Riot является "открытым стеком технологий". Он предназначен для разработчиков которые хотят избежать фреймворков загоняющих в жесткие рамки. Его инструменты позволяют сочетать в вашем коде различные шаблоны проектирования. Такие системы как Facebook Flux могут быть [самодельными](https://github.com/jimsparkman/RiotControl).

> Взглянув на пример riot.js, я настолько удивился его простоте что аж ужаснулся.<br>
  <small>(I looked at the riot.js example, and it feels so clean, it's scary.)</small><br>
  [@paulbjensen](https://twitter.com/paulbjensen/status/558378720403419137)<br><br>
  Это то, к чему я буду стремится, если я захочу разработать свой фреймворк.<br>
  <small>(This is what I would aim for if I wanted to make a JS framework.)</small><br>
  [@ddunderfelt](https://twitter.com/ddunderfelt/status/558522477081788416)<br><br>
  Это один из лучших кусков кода которые я видел в мире #js<br>
  <small>(This is one of the best piece of code I have seen in #js world.)</small><br>
  [@notarianni](https://twitter.com/notarianni/status/421388764334669825)<br><br>
  Riot.js настолько мал, что я успел изучить большую часть его пока моя девушка примеряла наряды.<br>
  <small>(Riot.js is so tiny, I learned most of it while waiting for my GF trying on clothes.)</small><br>
  [@kkovacs](https://twitter.com/kkovacs/status/422063156945764352)<br>

### Заключение

Riot это React + Polymer + модели + маршруты в минимум строк кода. И это работает уже сегодня, даже в IE8. Riot очень прост в использовании и почти ничего не весит. Не надо изобретать велосипед, надо просто взять лучшее и сделать простые и удобные в использовании инструменты.

Мы должны сосредоточится на компонетах которые можно будет повторно ипользовать, а не о том, чтобы придерживаться шаблона. Со слов разработчиков о React:

> "Шаблоны разделяют технологии, но не решают проблем"<br>
  <small>("Templates separate technologies, not concerns.")</small>

При наличии связанных между собой отображения и логики в одном компоненте общая система становится проще и прозрачнее. Мы выражаем свое уважение React'у за это важное понимание.
