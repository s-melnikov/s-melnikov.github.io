
title: Сравнение
subtitle: Чем Riot отличается от React и Polymer
date: Tue Feb 24 2015 18:55:14

====

## React

Riot 2.0 вдохновлен идеями React и принципом "единства". Со слов разработчиков Facebook:

> "Шаблоны разделяют технологии, но не решают проблем."

Вместо разработки по шаблонам мы должны разрабатывать многократно используемые компоненты. Разделяя логикупо шаблону нас сдерживает те вещи, которые взаимосвязаны между собой.

Комбинируя эти взаимосвязанные технологии вместе в одном компоненте позволяет системе оставаться простой. Мы уважаем React за понимание этой важной кончепции.

React замечательно помог нам и мы до сих пор его используем в [Disqus Importer](https://muut.com/importer/), но мы обеспокоены его синтаксисом и размером (_особенно_ синтаксисом). И мы задумались над тем, что он может быть проще: как внутреннее строение, так и внешне строение (для пользователей).

### React синтаксис

Следующий пример был взят с главной страницы React:

```lang-jsx
var TodoList = React.createClass({
  render: function() {
    var createItem = function(itemText) {
      return <li>{itemText}</li>;
    };
    return <ul>{this.props.items.map(createItem)}</ul>;
  }
});
var TodoApp = React.createClass({
  getInitialState: function() {
    return {items: [], text: ''};
  },
  onChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var nextItems = this.state.items.concat([this.state.text]);
    var nextText = '';
    this.setState({items: nextItems, text: nextText});
  },
  render: function() {
    return (
      <div>
        <h3>TODO</h3>
        <TodoList items={this.state.items} />
        <form onSubmit={this.handleSubmit}>
          <input onChange={this.onChange} value={this.state.text} />
          <button>{'Add #' + (this.state.items.length + 1)}</button>
        </form>
      </div>
    );
  }
});

React.render(<TodoApp />, mountNode);
```

JSX - это смесь HTML и JavaScript. Вы можете использовать HTML в любой части компонента: как в методах, так и в определениях параметров.

### Riot синтаксис

То же самое, но уже с Riot:

```lang-jsx
<todo>
  <h3>TODO</h3>

  <ul>
    <li each={ item, i in items }>{ item }</li>
  </ul>

  <form onsubmit={ handleSubmit }>
    <input>
    <button>Add #{ items.length + 1 }</button>
  </form>

  this.items = []

  handleSubmit(e) {
    var input = e.target[0]
    this.items.push(input.value)
    input.value = ''
  }
</todo>
```
И так мы монтируем этот тег на страницу:

```lang-markup
<todo></todo>

<script>riot.mount('todo')</script>
```

### Похожи, но разные

В Riot на первом месте идет HTML и на втором месте JavaScript. И они оба соединены в одном компоненте, но при этом они оккуратно отделены друг от друга. JavaScript выражения можно смешивать с HTML.

Никаких особенных вещей за исключением нотации выражений в фигурных скобках.

Как видно, в коде приложений меньше шаблонности. Меньше скобок, запятых, системных свойств и имен методов. Строки могут быть преобразованы как `"Hello {world}"` вместо `"Hello " + this.state.world` и методы могут быть определены с помощью компактного ES6 синтаксиса. Простота во всем.

Мы считаем что синтаксис Riot - это более простой способ отделить отображение и логику и насладится преимуществами изолированых компонентов.

### Строка против DOM

Во время инициализации компонента React разбирает строку а Riot разбирает DOM дерево.

Riot находит выражения в дереве элементов и сохраняет их в отдельный массив. Каждое выражение привязанно к определенному узлу DOM. При каждом запуске эти выражения пересчитываются и сравниваются со значениями в DOM. Если значения отличаются то соответствующий узел DOM обновляется. В некоторм смысле у Riot есть свой виртуальный DOM, только упрощенный вариант.

Поскольку эти выражения закешированы они обновляются очень быстро. Время, за которое вычисляются 100, или даже 1000 выражений обычно занимает менее 1мс.

Алгоритм синхронизации React более сложный поскольку HTML слой может изменяться случайным образом после каждого обновления. Учитывая эту сложную задачу, Facebook работчикам пришлось неплохо попотеть над ним.

Мы выдили что эту сложность можно избежать.

В Riot HTML структура фиксированая. Только циклы и условия могут добавлять и удалять элементы. Для примера, `div` не может быть конвертирован в `label`. Riot может только обновить выражения без сложных замен в дереве элементов.

### Flux и маршрутизация

React взаимодействует только с UI и это является верным решением. Все популярные програмные проекты имеет четкий фокус.

Facebook рекомендует использовать [Flux](http://facebook.github.io/flux/docs/overview.html) для структурирования клиентского кода. Это скорее шаблон проектирования с интересными идеями, чем фреймворк.

Riot из коробки имеет систему пользовательских тегов, систему работы с событиями (observable) и маршрутизатор. Мы верим что это фундаментальные блоки клиентского приложения. Система событий привносит модульность, маршрутизатор позволяет следить за URL и кнопкой "назад", а пользовательские теги заботятся об интерфейсе приложения.

Также как и Flux, Riot является гибким и оставляет большие архитектурные решения за разработчиками. Riot лишь инструмент, который поможет вам в достижении цели.

Вы можете построить Flux подобную систему используя лишь Riot наблюдатель (observable) и маршрутизатор (router). Или вы можете воспользоваться готовой реализацией Flux с Riot уже сегодня.

### Больше в разы

React в 24 раза больше чем Riot.

<small>_react.min.js_ – 127Kb</small>
<span class="bar red"></span>

<small>_riot.min.js_ – 5.7Kb</small>
<span class="bar blue" style="width: 4.3%"></span>

Рекомендуемый React маршрутизатор в 128x больше чем маршрутизатор в Riot.

<small>_react-router.min.js_ – 54.9Kb</small>
<span class="bar red"></span>

<small>_react-mini-router.min.js_ – 8.6Kb</small>
<span class="bar red" style="width: 15.6%"></span>

<small>_riot.router.min.js_ – 0.43Kb</small>
<span class="bar blue" style="width: 0.7%"></span>

По правде, это сравнение маршрутизаторов немного несправедливо, потому что [react-router](https://github.com/rackt/react-router) имеет гораздо больше возможностей. Но диаграмма выше четко обозначила цель Riot: это предоставить как можно минималистичней API для работы.

Экосистема React более загнана в рамки и предоставляет больше API для работы. Хорошей альтернативой является более популярный в React сообществе маршрутизатор [react-mini-router](https://github.com/larrymyers/react-mini-router).

## Polymer

Polymer имеет Web Component стандарт что делает его доступным только для новейших браузеров. Это позволяет вам описывать пользовательские теги стандартным способом.

Концептуально Riot позволяет тоже самое, но есть и различия:

1.  Riot использует виртуальный DOM и только те элементы, которые были изменены, обновляются, в результате мы получаем меньшее количество операций с DOM.
2.  Polymer использует более сложный синтаксис и требует изучения большого количества материала и книг.
3.  Отдельные компоненты импортируются при помощи `link rel="import"`. Полифилы вынуждены прибегать к очереди XHR запросов, что делает их заметно медленными. Riot теги импортируются при помощи `script src` и множество тегов могут быть объединены обычными средствами.
4.  Polymer использует двухсторонее связывание, Riot использует одностороннее.
5.  Нет возможности для рендера на стороне сервера, который будет частью Riot в следуещей версии.

### Больше в 22 раза

Polymer (v0.5.2) больше чем Riot в 22 раза.

<small>_polymer.min.js_ – 120Kb</small>
<span class="bar red"></span>

<small>_riot.min.js_ – 6.7Kb</small>
<span class="bar blue" style="width: 4.5%"></span>

Как утверждают, Web components [лидер проблем с полифилами](http://developer.telerik.com/featured/web-components-arent-ready-production-yet/) и это то, почему Polymer требует такого большого количества кода.

### Экспериментальный

Polymer базируется на экспериментальных технологиях. Нативно Web Component не поддерживается в Safari и IE. В IE статус "в разработке", а в Safari пока совсем не известно с планами насчет Web components. Некоторые WebKit [комиты](https://lists.webkit.org/pipermail/webkit-dev/2013-May/024894.html)  намекают на то, что планируется не полная поддержка стандарта. И поэтому Polymer способен работать только с полифилами в _самых последних версиях_ еще “зеленых” (“evergreen”) браузерах (IE 10+).

Проекту Polymer уже более [2 лет](https://github.com/Polymer/polymer/commit/0452ada044a6fc5818902e685fb07bb4678b2bc2) и он не получил никаких существенных применений. До сих пор не понятно, когда Web Components будут поддерживатся нативно.