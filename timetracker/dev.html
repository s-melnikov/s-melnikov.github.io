<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    html {
      box-sizing: border-box;
    }
    * {
      position: relative;
      box-sizing: inherit;
    }
    body {
      font-family: 'Fira Sans', Consolas, monospace;
      font-size: 13px;
      background-color: #f5f5f5;
      color: #444444;
    }
    .btn {
      cursor: pointer;
      border: none;
      background: none;
      font-family: inherit;
      color: inherit;
      font-size: inherit;
      padding: 0 5px;
      outline: 0;
    }
    .btn:hover {
      opacity: .9;
    }
    .btn-primary {
      color: blue;
    }
    .btn-warning {
      color: orange;
    }
    .btn-success {
      color: green;
    }
    .flex {
      display: flex;
    }
    input {
      display: block;
      width: 100%;
      border: 1px solid #dcdcdc;
      font-family: inherit;
      font-size: inherit;
      color: inherit;
      padding: 5px;
    }
    .day_title {
      padding: 20px 7px 10px;
      font-size: 110%;
    }
    .column {
      padding: 7px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-top: 1px solid transparent;
      border-bottom: 1px solid transparent;
    }
    .current .column {
      border-color: #dcdcdc;
    }
    .column_title {
      width: 360px;
    }
    .column_started {
      text-align: right;
      width: 170px;
    }
    .column_spended {
      text-align: right;
      width: 120px;
    }
    .column_actions {
      text-align: right;
      width: 115px;
    }
  </style>
</head>
<body>
  <script src="https://unpkg.com/hyperapp@1.2.8/dist/hyperapp.js"></script>
  <script>
    let
      nextTaskId = 1,
      nextTimestampId = 1;
    const
      DEV = location.pathname.indexOf('dev') !== -1,
      STORAGE = 'timetracker' + (DEV ? 'dev' : ''),
      LOCALE = 'ru-RU',
      WORK_DAY_DURATION = 8,
      { app, h } = hyperapp,
      stored = JSON.parse(localStorage[STORAGE] || "{}"),
      state = {
        tasks: stored.tasks || [{
          id: 0,
          title: '[Ignored task]'
        }],
        timestamps: stored.timestamps || [{
          id: 0,
          task: 0,
          timestamp: 0
        }],
        latestTasks: []
      },
      actions = {
        startNewTask: () => ({ tasks, timestamps, latestTasks }, { sync }) => {
          let now = Date.now();
          let newTask = {
            id: nextTaskId,
            title: `New task #${nextTaskId++}`
          };
          let newTimestamp = {
            id: nextTimestampId++,
            task: newTask.id,
            timestamp: now
          };
          latestTasks.map((task, i) => {
            if (task.current) {
              task.timeSpended += (now - task.lastTimestamp);
              delete task.current;
            }
          });
          requestIdleCallback(sync);
          return {
            tasks: [...tasks, newTask],
            timestamps: [...timestamps, newTimestamp],
            latestTasks: [Object.assign({
              timeStart: now,
              timeSpended: 0,
              lastTimestamp: now,
              current: true
            }, newTask), ...latestTasks]
          };
        },
        startTask: id => ({ timestamps, latestTasks }, { sync }) => {
          let now = Date.now();
          let newTimestamp = {
            id: nextTimestampId++,
            task: id,
            timestamp: now
          };
          let targetTask = latestTasks.find(task => task.id === id);
          latestTasks.splice(latestTasks.indexOf(targetTask), 1);
          latestTasks.forEach(task => {
            if (task.current) {
              task.timeSpended += (now - task.lastTimestamp);
              delete task.current;
            }
            return task;
          });
          targetTask.current = true;
          targetTask.lastTimestamp = now;
          latestTasks.unshift();
          requestIdleCallback(sync);
          return {
            timestamps: [...timestamps, newTimestamp],
            latestTasks: [targetTask, ...latestTasks]
          };
        },
        getLatestTasks: () => ({ tasks, timestamps }, { getLatestDaysTasks }) => {
          let now = Date.now();
          let oldest = now - 14 * 24 * 60 * 60 * 1000;
          let lastTimestamps = timestamps.filter(timestamp => timestamp.timestamp > oldest || !timestamp.task);
          let latestTasks = [];
          lastTimestamps.forEach((timestamp, i) => {
            let nextTimestamp = lastTimestamps[i + 1];
            let task = latestTasks.find(_task => _task.id === timestamp.task);
            if (task) {
              latestTasks.splice(latestTasks.indexOf(task), 1);
            } else {
              task = Object.assign({
                timeStart: timestamp.timestamp,
                timeSpended: 0
              }, tasks.find(_task => _task.id === timestamp.task));
            }
            latestTasks.push(task);
            if (nextTimestamp) {
              task.timeSpended += (nextTimestamp.timestamp - timestamp.timestamp);
              task.lastTimestamp = timestamp.timestamp;
            } else {
              task.timeSpended += (now - timestamp.timestamp);
              task.lastTimestamp = now;
              task.current = true;
            }
          });
          console.log(1, { latestTasks })
          getLatestDaysTasks(latestTasks);
        },
        getLatestDaysTasks: latestTasks => {
          let daysTasks = [];
          latestTasks.reverse().forEach(task => {
            let date = new Date(task.lastTimestamp);
            let day = date.toLocaleDateString(LOCALE);
            let dayTasks = daysTasks.find(_dayTasks => _dayTasks.day === day);
            if (!dayTasks) {
              dayTasks = { day, tasks: [] };
              daysTasks.push(dayTasks);
            }
            dayTasks.tasks.push(task);
          });
          return {
            latestTasks,
            daysTasks
          };
        },
        update: () => ({ latestTasks }) => {
          let [ currenttask ] = latestTasks;
          let now = Date.now();
          if (currenttask) {
            currenttask.timeSpended += (now - currenttask.lastTimestamp);
            currenttask.lastTimestamp = now;
          }
          return {
            latestTasks
          };
        },
        makeTaskEditable: id => ({ latestTasks }) => {
          let task = latestTasks.find(task => task.id === id);
          task.editable = true;
          return { latestTasks };
        },
        editTitle: ({ id, title }) => ({ latestTasks }) => {
          let task = latestTasks.find(task => task.id === id);
          task.title = title;
          return { latestTasks };
        },
        saveTitle: id => ({ latestTasks }, { sync }) => {
          let task = latestTasks.find(task => task.id === id);
          task.editable = false;
          requestIdleCallback(sync);
          return { latestTasks };
        },
        sync: () => ({ tasks, timestamps }) => {
          localStorage[STORAGE] = JSON.stringify({ tasks, timestamps });
        },
        showTaskInfo: id => ({ latestTasks }) => {
          let task = Object.assign({}, latestTasks.find(t => t.id === id));
          task.lastTimestamp = new Date(task.lastTimestamp).toUTCString();
          task.timeStart = new Date(task.timeStart).toUTCString();
          task.timeSpended = timeSpendedString(task.timeSpended);
          console.log(task);
        },
        showTaskTimestamps: id => ({ timestamps }) => {
          let taskTimestamps = timestamps
            .filter(timestamp => timestamp.task === id)
            .map(timestamp => Object.assign({}, timestamp, {
              timestamp: new Date(timestamp.timestamp).toUTCString()
            }));
          console.log(taskTimestamps);
        }
      },
      timeSpendedString = time => {
        time = Math.floor(time / 1000);
        let s, m, h, d;
        s = time % 60;
        m = ((time = Math.floor(time / 60)) % 60);
        h = ((time = Math.floor(time / 60)) % WORK_DAY_DURATION);
        d = Math.floor(time / WORK_DAY_DURATION);
        return `${d}d ${h}h ${m}m ${s}s`;
      },
      cloneArray = array => array.slice().map(item => Object.assign({}, item)),
      intervalIdleCallback = (cb, interval) => requestIdleCallback(() => {
        let tick = () => { cb(); setTimeout(() => requestIdleCallback(tick), interval); };
        requestIdleCallback(tick);
      }),
      TasksListView = ($s, $a) => {
        let { daysTasks } = $s;
        return daysTasks ? daysTasks.map(dayTasks => h('div', { class: 'day_tasks' },
          h('div', { class: 'day_title' }, dayTasks.day),
          TasksDayView(dayTasks.tasks, $a)
        )) : null;
      },
      TasksDayView = (tasks, $a) => {
        return tasks ? tasks.map(({ id, title, timeStart, timeSpended, current, editable }) => {
          if (!id) return null;
          timeStart = new Date(timeStart);
          return h('div', {
              class: 'row flex ' + (current ? ' current' : '')
            },
            h('div', {
                class: 'column column_title',
                title: title,
                ondblclick: event => $a.makeTaskEditable(id)
              },
              editable ? h('input', {
                oninput: event => $a.editTitle({ id, title: event.target.value }),
                onkeyup: event => {
                  if (event.key === "Enter") {
                    $a.saveTitle(id);
                  }
                },
                value: title
              }) : title
            ),
            h('div', {
                class: 'column column_started',
                onclick: () => $a.showTaskInfo(id)
              },
              `${timeStart.toLocaleDateString(LOCALE)} ${timeStart.toLocaleTimeString(LOCALE)}`),
            h('td', {
                class: 'column column_spended',
                onclick: () => $a.showTaskTimestamps(id)
              }, timeSpendedString(timeSpended)),
            h('td', { class: 'column column_actions' },
              current ? h('button', {
                class: 'btn btn-warning',
                onclick: event => $a.startTask(0)
              }, 'stop') : h('button', {
                class: 'btn btn-primary',
                onclick: event => $a.startTask(id)
              }, 'start'),
              h('button', {
                class: 'btn btn-success',
                onclick: () => {}
              }, 'merge')
            )
          );
        }) : null;
      }
      RootView = ($s, $a) => {
        return h('div', { id: 'container' },
          h('p', { class: 'control column' },
            h('button', {
              class: 'btn btn-primary',
              onclick: $a.startNewTask
            }, 'start new task')
          ),
          h('div', { class: 'days_tasks' }, TasksListView($s, $a))
        )
      }
    // mock(state);
    let { getLatestTasks, getLatestDaysTasks, update } = app(state, actions, RootView, document.body);
    getLatestTasks();
    // intervalIdleCallback(update, 1000);
    if (!!stored) {
      nextTaskId = stored.tasks[stored.tasks.length - 1].id + 1;
      nextTimestampId = stored.timestamps[stored.timestamps.length - 1].id + 1;
    }
    function mock({ tasks, timestamps }) {
      const HOUR = 60 * 60 * 1000;
      let lorem = "Lorem ipsum dolor sit amet consectetur adipisicing elit ea fugit iure aut deserunt eum ex labore eaque porro voluptatibus eos saepe magnam odit quia esse ab id eius ipsa maiores autem voluptates dignissimos necessitatibus perferendis quia nulla enim quas omnis dolorem quo veniam placeat cumque in quibusdam maxime voluptatum ad voluptatem expedita natus vero sequi provident quas et aliquid doloribus cumque delectus possimus quidem officia est quaerat unde expedita fugiat animi atque odio suscipit natus dolores asperiores libero cupiditate placeat consequuntur velit nisi Itaque tempora ad maxime officia voluptates accusantium unde eaque amet repellendus optio incidunt soluta asperiores sint possimus".split(" ");
      let shuffle = arr => arr.map(a => [Math.random(), a]).sort((a, b) => a[0] - b[0]).map(a => a[1]);
      let random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      let getTitle = () => {
        let title = shuffle(lorem).slice(0, random(3, 10)).join(" ");
        return title[0].toUpperCase() + title.slice(1);
      }
      let now = Date.now();
      let mockStartTime = now - 100 * 24 * HOUR;
      let timestamp = mockStartTime;
      let nextTaskId = 1;
      let nextTimestampId = 1;
      while (timestamp < now) {
        let newTask = {
          id: nextTaskId++,
          title: getTitle()
        };
        let newTimestamp = {
          id: nextTimestampId++,
          task: newTask.id,
          timestamp: timestamp
        }
        tasks.push(newTask);
        timestamps.push(newTimestamp);
        timestamp += random(HOUR, HOUR * 8);
      }
    }
  </script>
</body>
</html>
