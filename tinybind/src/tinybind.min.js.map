{"version":3,"file":"tinybind.min.js","sources":["../src/constants.js","../src/parsers.js","../src/observer.js","../src/tinybind.js","../src/bindings.js","../src/view.js","../src/adapter.js","../src/binders.js","../src/export.js"],"sourcesContent":["export const OPTIONS = [\r\n  'prefix',\r\n  'templateDelimiters',\r\n  'rootInterface',\r\n  'preloadData',\r\n  'handler'\r\n]\r\n\r\nexport const EXTENSIONS = [\r\n  'binders',\r\n  'formatters',\r\n  'adapters'\r\n]","const PRIMITIVE = 0\r\nconst KEYPATH = 1\r\nconst TEXT = 0\r\nconst BINDING = 1\r\n\r\nconst QUOTED_STR = /^'.*'$|^\".*\"$/\r\n\r\n// Parser and tokenizer for getting the type and value from a string.\r\nexport function parseType(string) {\r\n  let type = PRIMITIVE\r\n  let value = string\r\n\r\n  if (QUOTED_STR.test(string)) {\r\n    value = string.slice(1, -1)\r\n  } else if (string === 'true') {\r\n    value = true\r\n  } else if (string === 'false') {\r\n    value = false\r\n  } else if (string === 'null') {\r\n    value = null\r\n  } else if (string === 'undefined') {\r\n    value = undefined\r\n  } else if (!isNaN(string)) {\r\n    value = Number(string)\r\n  } else {\r\n    type = KEYPATH\r\n  }\r\n\r\n  return {type: type, value: value}\r\n}\r\n\r\n// Template parser and tokenizer for mustache-style text content bindings.\r\n// Parses the template and returns a set of tokens, separating static portions\r\n// of text from binding declarations.\r\nexport function parseTemplate(template, delimiters) {\r\n  var tokens\r\n  let length = template.length\r\n  let index = 0\r\n  let lastIndex = 0\r\n  let open = delimiters[0], close = delimiters[1]\r\n\r\n  while (lastIndex < length) {\r\n    index = template.indexOf(open, lastIndex)\r\n\r\n    if (index < 0) {\r\n      if (tokens) {\r\n        tokens.push({\r\n          type: TEXT,\r\n          value: template.slice(lastIndex)\r\n        })\r\n      }\r\n\r\n      break\r\n    } else {\r\n      tokens || (tokens = [])\r\n      if (index > 0 && lastIndex < index) {\r\n        tokens.push({\r\n          type: TEXT,\r\n          value: template.slice(lastIndex, index)\r\n        })\r\n      }\r\n\r\n      lastIndex = index + open.length\r\n      index = template.indexOf(close, lastIndex)\r\n\r\n      if (index < 0) {\r\n        let substring = template.slice(lastIndex - close.length)\r\n        let lastToken = tokens[tokens.length - 1]\r\n\r\n        if (lastToken && lastToken.type === TEXT) {\r\n          lastToken.value += substring\r\n        } else {\r\n          tokens.push({\r\n            type: TEXT,\r\n            value: substring\r\n          })\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      let value = template.slice(lastIndex, index).trim()\r\n\r\n      tokens.push({\r\n        type: BINDING,\r\n        value: value\r\n      })\r\n\r\n      lastIndex = index + close.length\r\n    }\r\n  }\r\n\r\n  return tokens\r\n}\r\n","\r\n// Check if a value is an object than can be observed.\r\nfunction isObject(obj) {\r\n  return typeof obj === 'object' && obj !== null\r\n}\r\n\r\n// Error thrower.\r\nfunction error(message) {\r\n  throw new Error('[Observer] ' + message)\r\n}\r\n\r\nvar adapters\r\nvar interfaces\r\nvar rootInterface\r\n\r\n// Constructs a new keypath observer and kicks things off.\r\nfunction Observer(obj, keypath, callback) {\r\n  this.keypath = keypath\r\n  this.callback = callback\r\n  this.objectPath = []\r\n  this.parse()\r\n  this.obj = this.getRootObject(obj)\r\n\r\n  if (isObject(this.target = this.realize())) {\r\n    this.set(true, this.key, this.target, this.callback)\r\n  }\r\n}\r\n\r\nObserver.updateOptions = function(options) {\r\n  adapters = options.adapters\r\n  interfaces = Object.keys(adapters)\r\n  rootInterface = options.rootInterface\r\n}\r\n\r\n// Tokenizes the provided keypath string into interface + path tokens for the\r\n// observer to work with.\r\nObserver.tokenize = function(keypath, root) {\r\n  var tokens = []\r\n  var current = {i: root, path: ''}\r\n  var index, chr\r\n\r\n  for (index = 0; index < keypath.length; index++) {\r\n    chr = keypath.charAt(index)\r\n\r\n    if (!!~interfaces.indexOf(chr)) {\r\n      tokens.push(current)\r\n      current = {i: chr, path: ''}\r\n    } else {\r\n      current.path += chr\r\n    }\r\n  }\r\n\r\n  tokens.push(current)\r\n  return tokens\r\n}\r\n\r\n// Parses the keypath using the interfaces defined on the view. Sets variables\r\n// for the tokenized keypath as well as the end key.\r\nObserver.prototype.parse = function() {\r\n  var path, root\r\n\r\n  if (!interfaces.length) {\r\n    error('Must define at least one adapter interface.')\r\n  }\r\n\r\n  if (!!~interfaces.indexOf(this.keypath[0])) {\r\n    root = this.keypath[0]\r\n    path = this.keypath.substr(1)\r\n  } else {\r\n    root = rootInterface\r\n    path = this.keypath\r\n  }\r\n\r\n  this.tokens = Observer.tokenize(path, root)\r\n  this.key = this.tokens.pop()\r\n}\r\n\r\n// Realizes the full keypath, attaching observers for every key and correcting\r\n// old observers to any changed objects in the keypath.\r\nObserver.prototype.realize = function() {\r\n  var current = this.obj\r\n  var unreached = -1\r\n  var prev\r\n  var token\r\n\r\n  for (let index = 0; index < this.tokens.length; index++) {\r\n    token = this.tokens[index]\r\n    if (isObject(current)) {\r\n      if (typeof this.objectPath[index] !== 'undefined') {\r\n        if (current !== (prev = this.objectPath[index])) {\r\n          this.set(false, token, prev, this)\r\n          this.set(true, token, current, this)\r\n          this.objectPath[index] = current\r\n        }\r\n      } else {\r\n        this.set(true, token, current, this)\r\n        this.objectPath[index] = current\r\n      }\r\n\r\n      current = this.get(token, current)\r\n    } else {\r\n      if (unreached === -1) {\r\n        unreached = index\r\n      }\r\n\r\n      if (prev = this.objectPath[index]) {\r\n        this.set(false, token, prev, this)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (unreached !== -1) {\r\n    this.objectPath.splice(unreached)\r\n  }\r\n\r\n  return current\r\n}\r\n\r\n// Updates the keypath. This is called when any intermediary key is changed.\r\nObserver.prototype.sync = function() {\r\n  var next, oldValue, newValue\r\n\r\n  if ((next = this.realize()) !== this.target) {\r\n    if (isObject(this.target)) {\r\n      this.set(false, this.key, this.target, this.callback)\r\n    }\r\n\r\n    if (isObject(next)) {\r\n      this.set(true, this.key, next, this.callback)\r\n    }\r\n\r\n    oldValue = this.value()\r\n    this.target = next\r\n    newValue = this.value()\r\n    if (newValue !== oldValue || newValue instanceof Function) this.callback.sync()\r\n  } else if (next instanceof Array) {\r\n    this.callback.sync()\r\n  }\r\n}\r\n\r\n// Reads the current end value of the observed keypath. Returns undefined if\r\n// the full keypath is unreachable.\r\nObserver.prototype.value = function() {\r\n  if (isObject(this.target)) {\r\n    return this.get(this.key, this.target)\r\n  }\r\n}\r\n\r\n// Sets the current end value of the observed keypath. Calling setValue when\r\n// the full keypath is unreachable is a no-op.\r\nObserver.prototype.setValue = function(value) {\r\n  if (isObject(this.target)) {\r\n    adapters[this.key.i].set(this.target, this.key.path, value)\r\n  }\r\n}\r\n\r\n// Gets the provided key on an object.\r\nObserver.prototype.get = function(key, obj) {\r\n  return adapters[key.i].get(obj, key.path)\r\n}\r\n\r\n// Observes or unobserves a callback on the object using the provided key.\r\nObserver.prototype.set = function(active, key, obj, callback) {\r\n  var action = active ? 'observe' : 'unobserve'\r\n  adapters[key.i][action](obj, key.path, callback)\r\n}\r\n\r\n\r\n// Unobserves the entire keypath.\r\nObserver.prototype.unobserve = function() {\r\n  var obj\r\n  var token\r\n\r\n  for (let index = 0; index < this.tokens.length; index++) {\r\n    token = this.tokens[index]\r\n    if (obj = this.objectPath[index]) {\r\n      this.set(false, token, obj, this)\r\n    }\r\n  }\r\n\r\n  if (isObject(this.target)) {\r\n    this.set(false, this.key, this.target, this.callback)\r\n  }\r\n}\r\n// traverse the scope chain to find the scope which has the root property\r\n// if the property is not found in chain, returns the root scope\r\nObserver.prototype.getRootObject = function (obj) {\r\n  var rootProp, current;\r\n  if (!obj.$parent) {\r\n    return obj;\r\n  }\r\n\r\n  if (this.tokens.length) {\r\n    rootProp = this.tokens[0].path\r\n  } else {\r\n    rootProp = this.key.path\r\n  }\r\n\r\n  current = obj;\r\n  while (current.$parent && (current[rootProp] === undefined)) {\r\n    current = current.$parent\r\n  }\r\n\r\n  return current;\r\n}\r\n\r\nexport default Observer\r\n","import {EXTENSIONS} from './constants'\r\nimport {parseTemplate, parseType} from './parsers'\r\n\r\nconst tinybind = {\r\n  // Global binders.\r\n  binders: {},\r\n\r\n  // Global formatters.\r\n  formatters: {},\r\n\r\n  // Global sightglass adapters.\r\n  adapters: {},\r\n\r\n  // Default attribute prefix.\r\n  _prefix: 'rv',\r\n\r\n  _fullPrefix: 'rv-',\r\n\r\n  get prefix () {\r\n    return this._prefix\r\n  },\r\n\r\n  set prefix (value) {\r\n    this._prefix = value\r\n    this._fullPrefix = value + '-'\r\n  },\r\n\r\n  parseTemplate: parseTemplate,\r\n\r\n  parseType: parseType,\r\n\r\n  // Default template delimiters.\r\n  templateDelimiters: ['{', '}'],\r\n\r\n  // Default sightglass root interface.\r\n  rootInterface: '.',\r\n\r\n  // Preload data by default.\r\n  preloadData: true,\r\n\r\n  // Default event handler.\r\n  handler: function(context, ev, binding) {\r\n    this.call(context, ev, binding.view.models)\r\n  },\r\n\r\n  // Sets the attribute on the element. If no binder above is matched it will fall\r\n  // back to using this binder.\r\n  fallbackBinder: function(el, value) {\r\n    if (value != null) {\r\n      el.setAttribute(this.type, value)\r\n    } else {\r\n      el.removeAttribute(this.type)\r\n    }  \r\n  },\r\n\r\n  // Merges an object literal into the corresponding global options.\r\n  configure: function(options) {\r\n    if (!options) {\r\n      return\r\n    }\r\n    Object.keys(options).forEach(option => {\r\n      let value = options[option]\r\n\r\n      if (EXTENSIONS.indexOf(option) > -1) {\r\n        Object.keys(value).forEach(key => {\r\n          this[option][key] = value[key]\r\n        })\r\n      } else {\r\n        this[option] = value\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport default tinybind\r\n","import {parseType} from './parsers'\r\nimport Observer from './observer'\r\n\r\nfunction getInputValue(el) {\r\n  let results = []\r\n  if (el.type === 'checkbox') {\r\n    return el.checked\r\n  } else if (el.type === 'select-multiple') {\r\n\r\n    el.options.forEach(option => {\r\n      if (option.selected) {\r\n        results.push(option.value)\r\n      }\r\n    })\r\n\r\n    return results\r\n  } else {\r\n    return el.value\r\n  }\r\n}\r\n\r\nconst FORMATTER_ARGS =  /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g\r\nconst FORMATTER_SPLIT = /\\s+/\r\n\r\n// A single binding between a model attribute and a DOM element.\r\nexport class Binding {\r\n  // All information about the binding is passed into the constructor; the\r\n  // containing view, the DOM node, the type of binding, the model object and the\r\n  // keypath at which to listen for changes.\r\n  constructor(view, el, type, keypath, binder, arg, formatters) {\r\n    this.view = view\r\n    this.el = el\r\n    this.type = type\r\n    this.keypath = keypath\r\n    this.binder = binder\r\n    this.arg = arg\r\n    this.formatters = formatters\r\n    this.formatterObservers = {}\r\n    this.model = undefined\r\n  }\r\n\r\n  // Observes the object keypath\r\n  observe(obj, keypath) {\r\n    return new Observer(obj, keypath, this)\r\n  }\r\n\r\n  parseTarget() {\r\n    if (this.keypath) {\r\n      let token = parseType(this.keypath)\r\n\r\n      if (token.type === 0) {\r\n        this.value = token.value\r\n      } else {\r\n        this.observer = this.observe(this.view.models, this.keypath)\r\n        this.model = this.observer.target\r\n      }\r\n    } else {\r\n      this.value = undefined;\r\n    }\r\n  }\r\n\r\n  parseFormatterArguments(args, formatterIndex) {\r\n    return args\r\n      .map(parseType)\r\n      .map(({type, value}, ai) => {\r\n        if (type === 0) {\r\n          return value\r\n        } else {\r\n          if (!this.formatterObservers[formatterIndex]) {\r\n            this.formatterObservers[formatterIndex] = {}\r\n          }\r\n\r\n          let observer = this.formatterObservers[formatterIndex][ai]\r\n\r\n          if (!observer) {\r\n            observer = this.observe(this.view.models, value)\r\n            this.formatterObservers[formatterIndex][ai] = observer\r\n          }\r\n\r\n          return observer.value()\r\n        }\r\n      })\r\n  }\r\n\r\n  // Applies all the current formatters to the supplied value and returns the\r\n  // formatted value.\r\n  formattedValue(value) {\r\n    return this.formatters.reduce((result, declaration, index) => {\r\n      let args = declaration.match(FORMATTER_ARGS)\r\n      let id = args.shift()\r\n      let formatter = this.view.options.formatters[id]\r\n\r\n      const processedArgs = this.parseFormatterArguments(args, index)\r\n\r\n      if (formatter && (formatter.read instanceof Function)) {\r\n        result = formatter.read(result, ...processedArgs)\r\n      } else if (formatter instanceof Function) {\r\n        result = formatter(result, ...processedArgs)\r\n      }\r\n      return result\r\n    }, value)\r\n  }\r\n\r\n  // Returns an event handler for the binding around the supplied function.\r\n  eventHandler(fn) {\r\n    let binding = this\r\n    let handler = binding.view.options.handler\r\n\r\n    return function(ev) {\r\n      handler.call(fn, this, ev, binding)\r\n    }\r\n  }\r\n\r\n  // Sets the value for the binding. This Basically just runs the binding routine\r\n  // with the supplied value formatted.\r\n  set(value) {\r\n    if ((value instanceof Function) && !this.binder.function) {\r\n      value = this.formattedValue(value.call(this.model))\r\n    } else {\r\n      value = this.formattedValue(value)\r\n    }\r\n\r\n    let routineFn = this.binder.routine || this.binder\r\n\r\n    if (routineFn instanceof Function) {\r\n      routineFn.call(this, this.el, value)\r\n    }\r\n  }\r\n\r\n  // Syncs up the view binding with the model.\r\n  sync() {\r\n    if (this.observer) {\r\n      this.model = this.observer.target\r\n      this.set(this.observer.value())\r\n    } else {\r\n      this.set(this.value)\r\n    }\r\n  }\r\n\r\n  // Publishes the value currently set on the input element back to the model.\r\n  publish() {\r\n    if (this.observer) {\r\n      var value = this.formatters.reduceRight((result, declaration, index) => {\r\n        const args = declaration.split(FORMATTER_SPLIT)\r\n        const id = args.shift()\r\n        const formatter = this.view.options.formatters[id]\r\n        const processedArgs = this.parseFormatterArguments(args, index)\r\n\r\n        if (formatter && formatter.publish) {\r\n          result = formatter.publish(result, ...processedArgs)\r\n        }\r\n        return result\r\n      }, this.getValue(this.el))\r\n\r\n      this.observer.setValue(value)\r\n    }\r\n  }\r\n\r\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\r\n  // routines will also listen for changes on the element to propagate them back\r\n  // to the model.\r\n  bind() {\r\n    this.parseTarget()\r\n\r\n    if (this.binder.hasOwnProperty('bind')) {\r\n      this.binder.bind.call(this, this.el)\r\n    }\r\n\r\n    if (this.view.options.preloadData) {\r\n      this.sync()\r\n    }\r\n  }\r\n\r\n  // Unsubscribes from the model and the element.\r\n  unbind() {\r\n    if (this.binder.unbind) {\r\n      this.binder.unbind.call(this, this.el)\r\n    }\r\n\r\n    if (this.observer) {\r\n      this.observer.unobserve()\r\n    }\r\n\r\n    Object.keys(this.formatterObservers).forEach(fi => {\r\n      let args = this.formatterObservers[fi]\r\n\r\n      Object.keys(args).forEach(ai => {\r\n        args[ai].unobserve()\r\n      })\r\n    })\r\n\r\n    this.formatterObservers = {}\r\n  }\r\n\r\n  // Updates the binding's model from what is currently set on the view. Unbinds\r\n  // the old model first and then re-binds with the new model.\r\n  update(models = {}) {\r\n    if (this.observer) {\r\n      this.model = this.observer.target\r\n    }\r\n\r\n    if (this.binder.update) {\r\n      this.binder.update.call(this, models)\r\n    }\r\n  }\r\n\r\n  // Returns elements value\r\n  getValue(el) {\r\n    if (this.binder && this.binder.getValue) {\r\n      return this.binder.getValue.call(this, el)\r\n    } else {\r\n      return getInputValue(el)\r\n    }\r\n  }\r\n}\r\n","import tinybind from './tinybind'\r\nimport {Binding} from './bindings'\r\nimport {parseTemplate} from './parsers'\r\n\r\nconst textBinder = {\r\n  routine: (node, value) => {\r\n    node.data = (value != null) ? value : ''\r\n  }\r\n}\r\n\r\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g\r\n\r\nconst parseNode = (view, node) => {\r\n  let block = false\r\n\r\n  if (node.nodeType === 3) {\r\n    let tokens = parseTemplate(node.data, tinybind.templateDelimiters)\r\n\r\n    if (tokens) {\r\n      for (let i = 0; i < tokens.length; i++) {\r\n        let token = tokens[i]\r\n        let text = document.createTextNode(token.value)\r\n        node.parentNode.insertBefore(text, node)\r\n\r\n        if (token.type === 1) {\r\n          view.buildBinding(text, null, token.value, textBinder, null)\r\n        }\r\n      }\r\n\r\n      node.parentNode.removeChild(node)\r\n    }\r\n    block = true\r\n  } else if (node.nodeType === 1) {\r\n    block = view.traverse(node)\r\n  }\r\n\r\n  if (!block) {\r\n    for (let i = 0; i < node.childNodes.length; i++) {\r\n      parseNode(view, node.childNodes[i]);\r\n    }\r\n  }\r\n}\r\n\r\nconst bindingComparator = (a, b) => {\r\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0\r\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0\r\n  return bPriority - aPriority\r\n}\r\n\r\nconst trimStr = (str) => {\r\n  return str.trim()\r\n}\r\n\r\n// A collection of bindings built from a set of parent nodes.\r\nexport default class View {\r\n  // The DOM elements and the model objects for binding are passed into the\r\n  // constructor along with any local options that should be used throughout the\r\n  // context of the view and it's bindings.\r\n  constructor(els, models, options) {\r\n    if (els.jquery || els instanceof Array) {\r\n      this.els = els\r\n    } else {\r\n      this.els = [els]\r\n    }\r\n\r\n    this.models = models\r\n    this.options = options\r\n\r\n    this.build()\r\n  }\r\n\r\n\r\n  buildBinding(node, type, declaration, binder, arg) {\r\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr)\r\n\r\n    let keypath = pipes.shift()\r\n\r\n    this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes))\r\n  }\r\n\r\n  // Parses the DOM tree and builds `Binding` instances for every matched\r\n  // binding declaration.\r\n  build() {\r\n    this.bindings = []\r\n\r\n    let elements = this.els, i, len;\r\n    for (i = 0, len = elements.length; i < len; i++) {\r\n      parseNode(this, elements[i])\r\n    }\r\n\r\n    this.bindings.sort(bindingComparator)\r\n  }\r\n\r\n  traverse(node) {\r\n    let bindingPrefix = tinybind._fullPrefix\r\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE'\r\n    let attributes = node.attributes\r\n    let bindInfos = []\r\n    let starBinders = this.options.starBinders\r\n    var type, binder, identifier, arg\r\n\r\n\r\n    for (let i = 0, len = attributes.length; i < len; i++) {\r\n      let attribute = attributes[i]\r\n      if (attribute.name.indexOf(bindingPrefix) === 0) {\r\n        type = attribute.name.slice(bindingPrefix.length)\r\n        binder = this.options.binders[type]\r\n        arg = undefined\r\n\r\n        if (!binder) {\r\n          for (let k = 0; k < starBinders.length; k++) {\r\n            identifier = starBinders[k]\r\n            if (type.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\r\n              binder = this.options.binders[identifier]\r\n              arg = type.slice(identifier.length - 1)\r\n              break\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!binder) {\r\n          binder = tinybind.fallbackBinder\r\n        }\r\n\r\n        if (binder.block) {\r\n          this.buildBinding(node, type, attribute.value, binder, arg)\r\n          node.removeAttribute(attribute.name)\r\n          return true;\r\n        }\r\n\r\n        bindInfos.push({attr: attribute, binder: binder, type: type, arg: arg})\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < bindInfos.length; i++) {\r\n      let bindInfo = bindInfos[i]\r\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg)\r\n      node.removeAttribute(bindInfo.attr.name)\r\n    }\r\n\r\n    return block\r\n  }\r\n\r\n  // Binds all of the current bindings for this view.\r\n  bind() {\r\n    this.bindings.forEach(binding => {\r\n      binding.bind()\r\n    })\r\n  }\r\n\r\n  // Unbinds all of the current bindings for this view.\r\n  unbind() {\r\n    this.bindings.forEach(binding => {\r\n      binding.unbind()\r\n    })\r\n  }\r\n\r\n  // Syncs up the view with the model by running the routines on all bindings.\r\n  sync() {\r\n    this.bindings.forEach(binding => {\r\n      binding.sync()\r\n    })\r\n  }\r\n\r\n  // Publishes the input values from the view back to the model (reverse sync).\r\n  publish() {\r\n    this.bindings.forEach(binding => {\r\n      if (binding.binder && binding.binder.publishes) {\r\n        binding.publish()\r\n      }\r\n    })\r\n  }\r\n\r\n  // Updates the view's models along with any affected bindings.\r\n  update(models = {}) {\r\n    Object.keys(models).forEach(key => {\r\n      this.models[key] = models[key]\r\n    })\r\n\r\n    this.bindings.forEach(binding => {\r\n      if (binding.update) {\r\n        binding.update(models)\r\n      }\r\n    })\r\n  }\r\n}\r\n","// The default `.` adapter that comes with tinybind.js. Allows subscribing to\r\n// properties on plain objects, implemented in ES5 natives using\r\n// `Object.defineProperty`.\r\n\r\nconst ARRAY_METHODS = [\r\n  'push',\r\n  'pop',\r\n  'shift',\r\n  'unshift',\r\n  'sort',\r\n  'reverse',\r\n  'splice'\r\n]\r\n\r\nconst adapter = {\r\n  counter: 0,\r\n  weakmap: {},\r\n\r\n  weakReference: function(obj) {\r\n    if (!obj.hasOwnProperty('__rv')) {\r\n      let id = this.counter++\r\n\r\n      Object.defineProperty(obj, '__rv', {\r\n        value: id\r\n      })\r\n    }\r\n\r\n    if (!this.weakmap[obj.__rv]) {\r\n      this.weakmap[obj.__rv] = {\r\n        callbacks: {}\r\n      }\r\n    }\r\n\r\n    return this.weakmap[obj.__rv]\r\n  },\r\n\r\n  cleanupWeakReference: function(ref, id) {\r\n    if (!Object.keys(ref.callbacks).length) {\r\n      if (!(ref.pointers && Object.keys(ref.pointers).length)) {\r\n        delete this.weakmap[id]\r\n      }\r\n    }\r\n  },\r\n\r\n  stubFunction: function(obj, fn) {\r\n    let original = obj[fn]\r\n    let map = this.weakReference(obj)\r\n    let weakmap = this.weakmap\r\n\r\n    obj[fn] = (...args) => {\r\n      let response = original.apply(obj, args)\r\n\r\n      Object.keys(map.pointers).forEach(r => {\r\n        let k = map.pointers[r]\r\n\r\n        if (weakmap[r]) {\r\n          if (weakmap[r].callbacks[k] instanceof Array) {\r\n            weakmap[r].callbacks[k].forEach(callback => {\r\n              callback.sync()\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      return response\r\n    }\r\n  },\r\n\r\n  observeMutations: function(obj, ref, keypath) {\r\n    if (obj instanceof Array) {\r\n      let map = this.weakReference(obj)\r\n\r\n      if (!map.pointers) {\r\n        map.pointers = {}\r\n\r\n        ARRAY_METHODS.forEach(fn => {\r\n          this.stubFunction(obj, fn)\r\n        })\r\n      }\r\n\r\n      if (!map.pointers[ref]) {\r\n        map.pointers[ref] = []\r\n      }\r\n\r\n      if (map.pointers[ref].indexOf(keypath) === -1) {\r\n        map.pointers[ref].push(keypath)\r\n      }\r\n    }\r\n  },\r\n\r\n  unobserveMutations: function(obj, ref, keypath) {\r\n    if ((obj instanceof Array) && (obj.__rv != null)) {\r\n      let map = this.weakmap[obj.__rv]\r\n\r\n      if (map) {\r\n        let pointers = map.pointers[ref]\r\n\r\n        if (pointers) {\r\n          let idx = pointers.indexOf(keypath)\r\n\r\n          if (idx > -1) {\r\n            pointers.splice(idx, 1)\r\n          }\r\n\r\n          if (!pointers.length) {\r\n            delete map.pointers[ref]\r\n          }\r\n\r\n          this.cleanupWeakReference(map, obj.__rv)\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  observe: function(obj, keypath, callback) {\r\n    var value;\r\n    let callbacks = this.weakReference(obj).callbacks\r\n\r\n    if (!callbacks[keypath]) {\r\n      callbacks[keypath] = []\r\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath)\r\n\r\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\r\n        value = obj[keypath]\r\n\r\n        Object.defineProperty(obj, keypath, {\r\n          enumerable: true,\r\n\r\n          get: () => {\r\n            return value\r\n          },\r\n\r\n          set: newValue => {\r\n            if (newValue !== value) {\r\n              this.unobserveMutations(value, obj.__rv, keypath)\r\n              value = newValue\r\n              let map = this.weakmap[obj.__rv]\r\n\r\n              if (map) {\r\n                let callbacks = map.callbacks[keypath]\r\n\r\n                if (callbacks) {\r\n                  callbacks.forEach(cb => {\r\n                      cb.sync()\r\n                  })\r\n                }\r\n\r\n                this.observeMutations(newValue, obj.__rv, keypath)\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    if (callbacks[keypath].indexOf(callback) === -1) {\r\n      callbacks[keypath].push(callback)\r\n    }\r\n\r\n    this.observeMutations(obj[keypath], obj.__rv, keypath)\r\n  },\r\n\r\n  unobserve: function(obj, keypath, callback) {\r\n    let map = this.weakmap[obj.__rv]\r\n\r\n    if (map) {\r\n      let callbacks = map.callbacks[keypath]\r\n\r\n      if (callbacks) {\r\n        let idx = callbacks.indexOf(callback)\r\n\r\n        if (idx > -1) {\r\n          callbacks.splice(idx, 1)\r\n\r\n          if (!callbacks.length) {\r\n            delete map.callbacks[keypath]\r\n            this.unobserveMutations(obj[keypath], obj.__rv, keypath)\r\n          }\r\n        }\r\n\r\n        this.cleanupWeakReference(map, obj.__rv)\r\n      }\r\n    }\r\n  },\r\n\r\n  get: function(obj, keypath) {\r\n    return obj[keypath]\r\n  },\r\n\r\n  set: (obj, keypath, value) => {\r\n    obj[keypath] = value\r\n  }\r\n}\r\n\r\nexport default adapter\r\n","import View from './view'\r\n\r\nconst getString = (value) => {\r\n  return value != null ? value.toString() : undefined\r\n}\r\n\r\nconst times = (n, cb) => {\r\n  for (let i = 0; i < n; i++) cb()\r\n}\r\n\r\nfunction createView(binding, data, anchorEl) {\r\n  let template = binding.el.cloneNode(true)\r\n  let view = new View(template, data, binding.view.options)\r\n  view.bind()\r\n  binding.marker.parentNode.insertBefore(template, anchorEl)\r\n  return view\r\n}\r\n\r\nconst binders = {\r\n  // Binds an event handler on the element.\r\n  'on-*': {\r\n    function: true,\r\n    priority: 1000,\r\n\r\n    unbind: function(el) {\r\n      if (this.handler) {\r\n        el.removeEventListener(this.arg, this.handler)\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (this.handler) {\r\n        el.removeEventListener(this.arg, this.handler)\r\n      }\r\n\r\n      this.handler = this.eventHandler(value)\r\n      el.addEventListener(this.arg, this.handler)\r\n    }\r\n  },\r\n\r\n  // Appends bound instances of the element in place for each item in the array.\r\n  'each-*': {\r\n    block: true,\r\n\r\n    priority: 4000,\r\n\r\n    bind: function(el) {\r\n      if (!this.marker) {\r\n        this.marker = document.createComment(` tinybind: ${this.type} `)\r\n        this.iterated = []\r\n\r\n        el.parentNode.insertBefore(this.marker, el)\r\n        el.parentNode.removeChild(el)\r\n      } else {\r\n        this.iterated.forEach(view => {\r\n          view.bind()\r\n        })\r\n      }\r\n    },\r\n\r\n    unbind: function(el) {\r\n      if (this.iterated) {\r\n        this.iterated.forEach(view => {\r\n          view.unbind()\r\n        })\r\n      }\r\n    },\r\n\r\n    routine: function(el, collection) {\r\n      let modelName = this.arg\r\n      collection = collection || []\r\n      let indexProp = el.getAttribute('index-property') || '$index'\r\n\r\n      collection.forEach((model, index) => {\r\n        let data = {$parent: this.view.models}\r\n        data[indexProp] = index\r\n        data[modelName] = model\r\n        let view = this.iterated[index]\r\n\r\n        if (!view) {\r\n\r\n          let previous = this.marker\r\n\r\n          if (this.iterated.length) {\r\n            previous = this.iterated[this.iterated.length - 1].els[0]\r\n          }\r\n\r\n          view = createView(this, data, previous.nextSibling)\r\n          this.iterated.push(view)\r\n        } else {\r\n          if (view.models[modelName] !== model) {\r\n            // search for a view that matches the model\r\n            let matchIndex, nextView\r\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\r\n              nextView = this.iterated[nextIndex]\r\n              if (nextView.models[modelName] === model) {\r\n                matchIndex = nextIndex\r\n                break\r\n              }\r\n            }\r\n            if (matchIndex !== undefined) {\r\n              // model is in other position\r\n              // todo: consider avoiding the splice here by setting a flag\r\n              // profile performance before implementing such change\r\n              this.iterated.splice(matchIndex, 1)\r\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0])\r\n              nextView.models[indexProp] = index\r\n            } else {\r\n              //new model\r\n              nextView = createView(this, data, view.els[0])\r\n            }\r\n            this.iterated.splice(index, 0, nextView)\r\n          } else {\r\n            view.models[indexProp] = index\r\n          }\r\n        }\r\n      })\r\n\r\n      if (this.iterated.length > collection.length) {\r\n        times(this.iterated.length - collection.length, () => {\r\n          let view = this.iterated.pop()\r\n          view.unbind()\r\n          this.marker.parentNode.removeChild(view.els[0])\r\n        })\r\n      }\r\n\r\n      if (el.nodeName === 'OPTION') {\r\n        this.view.bindings.forEach(binding => {\r\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\r\n            binding.sync()\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    update: function(models) {\r\n      let data = {}\r\n\r\n      //todo: add test and fix if necessary\r\n\r\n      Object.keys(models).forEach(key => {\r\n        if (key !== this.arg) {\r\n          data[key] = models[key]\r\n        }\r\n      })\r\n\r\n      this.iterated.forEach(view => {\r\n        view.update(data)\r\n      })\r\n    }\r\n  },\r\n\r\n  // Adds or removes the class from the element when value is true or false.\r\n  'class-*': function(el, value) {\r\n    let elClass = ` ${el.className} `\r\n\r\n    if (!value === (elClass.indexOf(` ${this.arg} `) > -1)) {\r\n      if (value) {\r\n        el.className = `${el.className} ${this.arg}`\r\n      } else {\r\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\r\n      }\r\n    }\r\n  },\r\n\r\n  // Sets the element's text value.\r\n  text: (el, value) => {\r\n    el.textContent = value != null ? value : ''\r\n  },\r\n\r\n  // Sets the element's HTML content.\r\n  html: (el, value) => {\r\n    el.innerHTML = value != null ? value : ''\r\n  },\r\n\r\n  // Shows the element when value is true.\r\n  show: (el, value) => {\r\n    el.style.display = value ? '' : 'none'\r\n  },\r\n\r\n  // Hides the element when value is true (negated version of `show` binder).\r\n  hide: (el, value) => {\r\n    el.style.display = value ? 'none' : ''\r\n  },\r\n\r\n  // Enables the element when value is true.\r\n  enabled: (el, value) => {\r\n    el.disabled = !value\r\n  },\r\n\r\n  // Disables the element when value is true (negated version of `enabled` binder).\r\n  disabled: (el, value) => {\r\n    el.disabled = !!value\r\n  },\r\n\r\n  // Checks a checkbox or radio input when the value is true. Also sets the model\r\n  // property when the input is checked or unchecked (two-way binder).\r\n  checked: {\r\n    publishes: true,\r\n    priority: 2000,\r\n\r\n    bind: function(el) {\r\n      var self = this;\r\n      if (!this.callback) {\r\n        this.callback = function () {\r\n          self.publish();\r\n        }\r\n      }\r\n      el.addEventListener('change', this.callback)\r\n    },\r\n\r\n    unbind: function(el) {\r\n      el.removeEventListener('change', this.callback)\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (el.type === 'radio') {\r\n        el.checked = getString(el.value) === getString(value)\r\n      } else {\r\n        el.checked = !!value\r\n      }\r\n    }\r\n  },\r\n\r\n  // Sets the element's value. Also sets the model property when the input changes\r\n  // (two-way binder).\r\n  value: {\r\n    publishes: true,\r\n    priority: 3000,\r\n\r\n    bind: function(el) {\r\n      this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\r\n      if (!this.isRadio) {\r\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input')\r\n\r\n        var self = this;\r\n        if (!this.callback) {\r\n          this.callback = function () {\r\n            self.publish();\r\n          }\r\n        }\r\n\r\n        el.addEventListener(this.event, this.callback)\r\n      }\r\n    },\r\n\r\n    unbind: function(el) {\r\n      if (!this.isRadio) {\r\n        el.removeEventListener(this.event, this.callback)\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (this.isRadio) {\r\n        el.setAttribute('value', value)\r\n      } else {\r\n        if (el.type === 'select-multiple') {\r\n          if (value instanceof Array) {\r\n            for (let i = 0; i < el.length; i++) {\r\n              let option = el[i];\r\n              option.selected = value.indexOf(option.value) > -1\r\n            }\r\n          }\r\n        } else if (getString(value) !== getString(el.value)) {\r\n          el.value = value != null ? value : ''\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // Inserts and binds the element and it's child nodes into the DOM when true.\r\n  if: {\r\n    block: true,\r\n    priority: 4000,\r\n\r\n    bind: function(el) {\r\n      if (!this.marker) {\r\n        this.marker = document.createComment(' tinybind: ' + this.type + ' ' + this.keypath + ' ');\r\n        this.attached = false\r\n\r\n        el.parentNode.insertBefore(this.marker, el)\r\n        el.parentNode.removeChild(el)\r\n      } else if (this.bound === false && this.nested) {\r\n        this.nested.bind()\r\n      }\r\n      this.bound = true\r\n    },\r\n\r\n    unbind: function() {\r\n      if (this.nested) {\r\n        this.nested.unbind()\r\n        this.bound = false\r\n      }\r\n    },\r\n\r\n    routine: function(el, value) {\r\n      if (!!value !== this.attached) {\r\n        if (value) {\r\n\r\n          if (!this.nested) {\r\n            this.nested = new View(el, this.view.models, this.view.options)\r\n            this.nested.bind()\r\n          }\r\n\r\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\r\n          this.attached = true\r\n        } else {\r\n          el.parentNode.removeChild(el)\r\n          this.attached = false\r\n        }\r\n      }\r\n    },\r\n\r\n    update: function(models) {\r\n      if (this.nested) {\r\n        this.nested.update(models)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default binders\r\n","import tinybind from './tinybind'\r\nimport View from './view'\r\nimport {OPTIONS, EXTENSIONS} from './constants'\r\nimport adapter from './adapter'\r\nimport binders from './binders'\r\nimport Observer from './observer'\r\n\r\n// Returns the public interface.\r\n\r\ntinybind.binders = binders\r\ntinybind.adapters['.'] = adapter\r\n\r\n// Binds some data to a template / element. Returns a tinybind.View instance.\r\ntinybind.bind = (el, models, options) => {\r\n  let viewOptions = {}\r\n  models = models || {}\r\n  options = options || {}\r\n\r\n  EXTENSIONS.forEach(extensionType => {\r\n    viewOptions[extensionType] = Object.create(null)\r\n\r\n    if (options[extensionType]) {\r\n      Object.keys(options[extensionType]).forEach(key => {\r\n        viewOptions[extensionType][key] = options[extensionType][key]\r\n      })\r\n    }\r\n\r\n    Object.keys(tinybind[extensionType]).forEach(key => {\r\n      if (!viewOptions[extensionType][key]) {\r\n        viewOptions[extensionType][key] = tinybind[extensionType][key]\r\n      }\r\n    })\r\n  })\r\n\r\n  OPTIONS.forEach(option => {\r\n    let value = options[option]\r\n    viewOptions[option] = value != null ? value : tinybind[option]\r\n  })\r\n\r\n  viewOptions.starBinders = Object.keys(viewOptions.binders).filter(function (key) {\r\n    return key.indexOf('*') > 0\r\n  })\r\n\r\n  Observer.updateOptions(viewOptions)\r\n\r\n  let view = new View(el, models, viewOptions)\r\n  view.bind()\r\n  return view\r\n}\r\n\r\ntinybind.formatters.negate = tinybind.formatters.not = function (value) {\r\n  return !value;\r\n};\r\n\r\nexport default tinybind\r\n"],"names":["OPTIONS","EXTENSIONS","QUOTED_STR","parseType","string","type","value","test","slice","undefined","isNaN","Number","parseTemplate","template","delimiters","tokens","length","index","lastIndex","open","close","indexOf","push","substring","lastToken","trim","adapters","interfaces","rootInterface","tinybind","this","_prefix","_fullPrefix","context","ev","binding","call","view","models","el","setAttribute","removeAttribute","options","keys","forEach","option","key","isObject","obj","Observer","keypath","callback","objectPath","parse","getRootObject","target","realize","set","updateOptions","Object","tokenize","root","chr","current","i","path","charAt","prototype","message","Error","substr","pop","prev","token","unreached","get","splice","sync","next","oldValue","newValue","Function","Array","setValue","active","action","unobserve","rootProp","$parent","FORMATTER_ARGS","FORMATTER_SPLIT","Binding","binder","arg","formatters","formatterObservers","model","observe","parseTarget","observer","parseFormatterArguments","args","formatterIndex","map","ai","_this","formattedValue","reduce","result","declaration","match","id","shift","formatter","_this2","processedArgs","read","eventHandler","fn","handler","function","routineFn","routine","publish","reduceRight","split","_this3","getValue","bind","hasOwnProperty","preloadData","unbind","_this4","fi","update","results","checked","selected","textBinder","node","data","DECLARATION_SPLIT","parseNode","block","nodeType","templateDelimiters","text","document","createTextNode","parentNode","insertBefore","buildBinding","removeChild","traverse","childNodes","bindingComparator","a","b","aPriority","priority","trimStr","str","View","els","jquery","build","pipes","bindings","len","elements","sort","identifier","bindingPrefix","nodeName","attributes","bindInfos","starBinders","attribute","name","binders","k","fallbackBinder","attr","bindInfo","publishes","ARRAY_METHODS","adapter","counter","defineProperty","weakmap","__rv","ref","callbacks","pointers","original","weakReference","response","apply","r","stubFunction","idx","cleanupWeakReference","desc","getOwnPropertyDescriptor","configurable","unobserveMutations","observeMutations","getString","toString","createView","anchorEl","cloneNode","marker","removeEventListener","addEventListener","iterated","createComment","collection","modelName","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","n","cb","elClass","className","replace","textContent","innerHTML","style","display","disabled","self","isRadio","tagName","event","bound","nested","attached","viewOptions","extensionType","create","filter","negate","not"],"mappings":"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"}