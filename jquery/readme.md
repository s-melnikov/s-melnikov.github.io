# I. Манипуляции DOM деревом

Зачастую программисты выбирают jQuery за умение манипулировать DOM деревом. Она предоставляет вам дружелюбный CSS синтаксис для выбора элементов, фильтрации, обхода, а также их модификации различными способами. В этой главе мы начнем с базовых приемов и постепенно перейдем к более сложным хитростям.



## 1. Событие ready

Первым шагом к манипулированию DOM является прослушка события ready DOM дерева. Это не только вопрос соглашения — событие срабатывает только когда все элементы страницы отобразились на экране и вы имеете к ним доступ, поэтому при выборе элементов с помощью jQuery вы получите верный результат. Но знаете ли вы, что существует лаконичный способ реализовать это кроссбраузерно и без jQuery? Вот как это делается:

```
// Способы отслеживания события готовности документа

// With jQuery
$(document).ready(function() { /* ... */});

// Short jQuery
$(function() { /* ... */});

// Without jQuery (doesn't work in older IE versions)
document.addEventListener('DOMContentLoaded',function() {
  // Your code goes here
});

// The Trickshot (works everywhere):

r(function() {
  alert('DOM Ready!');
})

function r(f){/in/.test(document.readyState)?setTimeout('r('+f+')',9):f()}
```

[Этот трюк](http://www.dustindiaz.com/smallest-domready-ever) заключается в проверке `document.readyState` свойства. Если оно содержит строку `in` (как в слове Loading), мы устанавливаем таймаут и проверяем снова. В противном случае мы запускаем функцию `f()`.



## 2. Выполнение конкретного кода для определенной страницы

Этот трюк касается только организации кода, но все же хорошо бы его знать. Если вы пишите объемный JavaScript, вскоре его станет тяжело отлаживать и вносить в него изменения. Особенно это актуально, когда большая часть кода содержится в одном файле, который подключается ко всем страницам вашего сайта. В конечном итоге получается так называемый "спагетти-код". Здесь представлен простой способ сохранить ваш код в читабельном состоянии и избежать ошибок. Вам нужно будет написать функцию маршрутизации, которая исполняет соответствующий JS для каждой конкретной страницы.

```
var route = {
  _routes: {}, // Все маршруты будут храниться тут

  add: function(url, action) {
    this._routes[url] = action;
  },

  run: function() {
    $.each(this._routes, function(pattern) {
      if (location.href.match(pattern)) {
        // "this" указывает на вызываемую функцию
        this();
      }
    });
  }
}

// Будет вызвана только на этой странице
route.add('002.html', function() {
  alert('Hello there!')
});

route.add('products.html', function() {
  alert("this won't be executed :(")
});

// Вы можете использовать даже регулярные выражения
route.add('.*.html', function() {
  alert('This is using a regex!')
});

route.run();
```

Каждая функция `action` вызывается в зависимости от текущего `url`.



## 3. Используйте оператор И

Логический оператор И не вычисляет второе выражение, если первое равно `false`. Вы можете использовать это в своих целях и избавить себя от написания полных конструкций `if`:

```
// Вместо этого:
if ($('#elem').length) {
  alert("doing something");
}
// Вы можете написать так:
$('#elem').length && alert("doing something");
```

Лучше всего это работает при проверке отдельных boolean переменных. Использовать такой метод в сложных условных выражениях не рекомендуется, так как это может сделать ваш код трудным для понимания.



## 4. Используйте jQuery метод is()

Метод `is()` мощнее, чем вы думаете. Вот несколько примеров:

html
```
<div id="elem"></div>
```

js
```
// Во-первых, сохраним элемент в переменную
var elem = $('#elem');

// Это div?
elem.is('div') && console.log("это див");

// У него есть класс bigbox?
elem.is('.bigbox') && console.log("у него есть класс bigbox");

// Он видимый? (мы скрыли его в данном примере)
elem.is(':not(:visible)') && console.log("он скрыт");

// Анимируем
elem.animate({'width': 200}, 1);

// Он анимируется?
elem.is(':animated') && console.log("он анимируется");
```

Результат:
```
это див
он скрыт
он анимируется
```

Вы можете передавать любые виды селекторов в метод `is()`. Также в этом примере используется трюк с операторм И из предыдущего совета, благодаря чему, в результате вы получаете три вышеперечисленные строки.



## 5. Определение количества элементов на странице

Чем больше элементов на вашей странице, тем медленнее она загружается. Данный трюк не окажет особого эффекта на скорость загрузки сайта, но это хороший способ проверить число элементов, особенно при редизайне сайта, когда вы хотите сделать ваш новый дизайн компактнее и легче.

Вот как это можно сделать с помощью jQuery:

```
// Сколько элементов содержит данная страница?
console.log('This page has ' + $('*').length + ' elements!');
```

Тут мы просто передаем универсальный селектор (который выбирает все содержимое) в jQuery и определяем число элементов.



## 6. Определение exist() функции

На данный момент, вы наверное, используете свойство `length` объекта jQuery для проверки существования элемента по заданному селектору. Следующий трюк сделает ваш код немного выразительнее и проще для чтения:

html
```
<div id="elem"></div>
```

js
```
// Старый способ:
console.log($('#elem').length == 1 ? "exists!" : "doesn't exist!");

// Новый способ:
jQuery.fn.exists = function() { return this.length > 0 }

console.log($('#elem').exists() ? "exists!" : "doesn't exist!");
```

Со временем вы начнете воспринимать этот метод как встроенный в jQuery по-умолчанию.



## 7. Используйте второй аргумент $() функции

Функция `$()` принимает два параметра. Знаете ли вы зачем нужен второй? Скажем, у нас есть такая вот разметка:

```
<ul id="firstList">
  <li>one</li>
  <li>two</li>
  <li>three</li>
</ul>
<ul id="secondList">
  <li>blue</li>
  <li>green</li>
</ul>
```

Продемонстрируем, зачем нужен этот второй параметр:

```
// Выбор элемента. #firstList является контекстом, ограничивающим поиск.
// Вы можете использовать селектор, jQuery объект или DOM элемент
$('li', '#firstList').each(function() {
  console.log($(this).html());
});

console.log('-----');

// Создание элемента. Второй аргумент
// это объект с jQuery методами, которые будут вызваны.
var div = $('<div>', {
  "class": "bigBlue",
  "css": {
    "background-color": "purple"
  },
  "width" : 20,
  "height": 20,
  "animate": { // Вы можете использовать любой jQuery метод в качестве свойства!
    "width": 200,
    "height": 50
  }
});
div.appendTo('body');
```

Контекст, который мы передаем в первом случае, является грубой альтернативой использованию метода `find()`.

```
$('#firstList').find('li');
```

Второй пример уберегает нас от вызова всех методов по отдельности.



## 8. Выделяйте внешние ссылки с помощью иконок

Для лучшей usability вам возможно понадобится добавить иконку рядом с сылкой, ведущей на другой вебсайт. Это легко сделать с помощью jQuery:

html
```
<ul id="links">
  <li><a href="007.html">The previous tip</a></li>
  <li><a href="./009.html">The next tip</a></li>
  <!-- Внешняя ссылка: -->
  <li><a href="http://www.google.com/">Google</a></li>
</ul>
```

js
```
// Обходим все ссылки
$('#links a').each(function() {
  if (this.hostname != location.hostname) {
    // Это внешняя ссылка
    $(this).append('<img src="external.png"/>').attr('target', '_blank');
  }
});
```

Если хотите, можете даже привязать прослушку события `click` по таким ссылкам и уведомлять пользователей о том, куда они ведут.



## 9. Освойте метод end()

Цепочки вызовов - один из самых полезных приемов, который делает jQuery столь эффективной. Метод `end()` мощный инструмент, которым вы можете впечатлить своих друзей. Он занимается тем, что восстанавливает вашу jQuery коллекцию в состояние, которое она принимала до последней модификации (фильтрации, поиска и т.д.) над ней. Пример:

html
```
<ul id="meals">
  <li>
    <ul class="breakfast">
      <li class="eggs">No</li>
      <li class="toast">No</li>
      <li class="juice">No</li>
    </ul>
  </li>
</ul>
```

js
```
var breakfast = $('#meals .breakfast');

breakfast
  .find('.eggs')
  .text('Yes')
  .end() // обратно к breakfast
  .find('.toast')
  .text('Yes')
  .end()
  .find('.juice')
  .toggleClass('juice coffee')
  .text('Yes');

breakfast.find('li').each(function() {
  console.log(this.className + ': ' + this.textContent);
});
```

В результате получаем:

```
eggs: Yes
toast: Yes
coffee: Yes
```



## 10. Предотвращение события click правой кнопкой мыши

Если вы хотите придать вашему веб приложению более естественное поведение, возможно вы захотите отменить клик правой кнопки мыши. Когда происходит клик правой кнопкой мыши, браузеры вызывают событие `contextmenu` и как любое другое событие, вы можете прослушать его и вызвать метод `preventDefault()`. Вот как это работает:

```
$(function() {
  $(document).on("contextmenu", function(e) {
    e.preventDefault();
  });
});
```

Вы можете пойти дальше и отобразить полноценное пользовательское контекстное меню, используя координаты, которые передаются в качестве свойств у объекта события `e`.



## 11. Вырывание из iframe

Некоторые сайты такие как StumbleUpon или Linkedin отображают ваш сайт вместе с их баром сверху страницы. Это сделано включением вашей страницы в `iframe`. Вот как вы можете это убрать:

```
if (window != window.top) {
  window.top.location = window.location;
}
```

Вам просто нужно сравнить объект `window` вашей страницы с объектом `window.top`. Обычно, они одинаковы, но если ваш сайт отображается внутри `iframe`, они будут отличаться. Затем вы просто перенаправляете браузер прямо на ваш сайт.



## 12. Разбор URL адресов с помощью ссылок

Разбор `url` на части — это серьезная заноза в заднице. Возможно, вашей первой мыслью будет найти регулярное выражение, которое сделает это. Но существует более простой способ — использование гиперссылок!

```
// Вы хотите разобрать этот адрес на части:
var url = 'http://tutorialzine.com/books/jquery-trickshots?trick=12#comments';
// Создайте новую ссылку со значением url в атрибуте href:
var a = $('<a>', {href: url});
console.log('Host name: ' + a.prop('hostname'));
console.log('Path: ' + a.prop('pathname'));
console.log('Query: ' + a.prop('search'));
console.log('Protocol: ' + a.prop('protocol'));
console.log('Hash: ' + a.prop('hash'));
```

Браузер автоматически распарсит адрес и присвоит свойствам объекта ссылки соответствующие части `url`. Результатом будет то, что вы получите всю сложную работу в готовом виде:

```
Host name: tutorialzine.com
Path: /books/jquery-trickshots
Query: ?trick=12
Protocol: http:
Hash: #comments
```



## 13. Сделай свою таблицу стилей редактируемой

Эта забавная хитрость покажет вам, что вы можете манипулировать встроенными блоками стилей точно также, как другими элементами. Они могут быть видимыми и даже редактируемыми с помощью небольшого jQuery сниппета.
Например, давайте предположим, что у нас есть следующая встроенная таблица (внутри тега `body`):

```
<style id="regular-style-block">
  html {
    background-color: #222229;
    position: relative;
  }
  body {
    font: 14px/1.3 'Segoe UI', Arial, sans-serif;
    color: #e4e4e9;
    min-height: 500px;
  }
</style>
```

Чтобы сделать этот блок видимым и редактируемым, запустите этот код в консоли:

```
$('#regular-style-block')
  .css({'display': 'block', 'white-space': 'pre'})
  .attr('contentEditable', true);
```

Изменения, которые вы внесете в эту таблицу стилей сразу же отразятся на вашей странице.


## 14. Отмена выделения текста

В определенной ситуации вам возможно захочется сделать так, чтобы текст на странице нельзя было выделить. Это полезно при создании интерфейсов позволяющих перемещать или переупорядочивать элементы страницы. И вы не хотите, чтобы пользователи случайно выделяли текст страницы. Ниже представлен сниппет, который выполняет эту функцию и работает во всех браузерах:

```
$('p.descr')
  .attr('unselectable', 'on')
  .css('user-select', 'none')
  .on('selectstart', false);
```



# II. Производительность

Веб-разработчики должны не только создавать работающие сайты, но и делать их быстрыми. Никому не нравятся страницы, которые бесконечно загружаются. В этой главе вы найдете советы и трюки по тому, как сделать ваш JavaScript быстрее и как ускорять ваши веб-приложения в дальнейшем. Если вы готовы, читайте дальше.



## 15. Подключение jQuery из CDN

Лучшее, что можно сделать в первую очередь для увеличение производительность JavaScipt вашего веб-сайта — просто подключить последнюю версию jQuery, так как каждый новый релиз несет за собой больше оптимизации и исправленных багов. Получение jQuery из CDN также хорошее решение, так как это минимизирут время загрузки вашего сайта (CDN быстрее передает библиотеку и многие пользователи могут хранить ее у себя в кэше).

```
<!-- Вариант 1 - запрос jQuery с официального CDN -->
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<!-- Вариант 2 - запрос jQuery с Google CDN (обратите внимание на протокол) -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<!-- Вариант 3 - запрос последних незначительных изменений 1.10.x (кэшируется только на час) -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10/jquery.min.js"></script>
<!-- Вариант 4 - запрос самой последней версии jQuery (используйте с осторожностью) -->
<script src="http://code.jquery.com/jquery.min.js"></script>
```

Помимо подключения конкретной версии библиотеки, вы можете выбрать конкретную версию с незначительными последними изменениями доступными на данный момент или даже запросить абсолютно новую версию jQuery. Используйте последний вариант с осторожностью, поскольку ваш код может перестать работать, если существуют критические изменения между последними релизами.



## 16. Обращайтесь к DOM как можно меньше

Несмотря на все достижения в производительности JavaScript, манипуляции с DOM все еще догоро обходятся и должны быть сведены к минимуму. Это особенно важно во время одновременной вставки большого количества элементов на страницу:

html
```
<div id="elem"></div>
```

js
```
// Плохо
var elem = $('#elem');
for (var i = 0; i < 100; i++) {
  elem.append('<li>element ' + i + '</li>');
}

// Хорошо
var elem = $('#elem'),
arr = [];
for (var i = 0; i < 100; i++) {
  arr.push('<li>element ' + i + '</li>');
}
elem.append(arr.join(''));
```

Группировка вставок в одну операцию быстрее, так как DOM перерисовывается только однажды. То же касается стилевых свойств: лучше назначить один css класс, чем применять несколько стилей.



## 17. Не бойтесь использовать нативный JS

Создание нового jQuery объекта несет за собой накладные расходы. Поэтому, если вы думаете о производительности, вам следует использовать нативный JavaScript там, где это возможно. Иногда, это даже проще и требует меньше кода. Вот пример:

```
// Выводим id всех лишек
$('#colors li').each(function() {
  // Добираемся к id напрямую, вместо использования jQuery $(this).attr('id')
  console.log(this.id);
});
```

Там, где производительность играет важнейщую роль, например, игры, canvas манипуляции или другие вычисления, избегайте jQuery и используйте нативные `for` циклы.



## 18. Оптимизируйте ваши селекторы

Если вам нужно немного дополнительной производительности, но вы хотите использовать jQuery, вам следует попытаться оптимизировать ваши селекторы. Здесь используются time и timeEnd методы консоли вашего браузера (больше информации о трюках с консолью смотрите в пункте 47) для измерения времени работы кода.

html
```
<div id="peanutButter">
  <div id="jelly" class="jellyTime"></div>
</div>
```

js
```
// Давайте проведем несколько измерений!
var iterations = 10000, i;
console.time('Fancy');
for (i = 0; i < iterations; i++) {
  // Это очень медленный способ обойти элементы DOM
  $('#peanutButter div:first');
}
console.timeEnd('Fancy');

console.time('Parent-child');
for (i = 0; i < iterations; i++) {
  // Лучше, но все равно медленно
  $('#peanutButter div');
}
console.timeEnd('Parent-child');

console.time('Parent-child by class');
for (i = 0; i < iterations; i++) {
  // Дле некоторых браузеров такой подход немного быстрее
  $('#peanutButter .jellyTime');
}
console.timeEnd('Parent-child by class');

console.time('By class name');
for (i = 0; i < iterations; i++) {
  // Еще лучше
  $('.jellyTime');
}
console.timeEnd('By class name');

console.time('By id');
for (i = 0; i < iterations; i++) {
  // Самый лучший
  $('#jelly');
}
console.timeEnd('By id');
```

Запуск этого примера в современном браузере приведет к примерно следующему результату:
Данные говорят о том, что выбор элемента по `id` в несколько раз быстрее остальных. И более сложные селекторы замедляют работу. Конечно, если вы ищете элемент только один раз, особой разницы в производительности вашего приложения вы не заметите. Но вам следует использовать другие трюки — кэширование jQuery объектов.



## 19. Используйте кэширование

Каждый раз, когда вы создаете новый объект jQuery, передавая селектор элемента, jQuery обходит DOM и связывает этот селектор с реальным элементом страницы. Это довольно медленный процесс в JavaScript, но ситуация меняется в лучшую сторону при использовании современных браузеров, которые поддерживают функцию `document.querySelector`, возвращающую элементы напрямую связанные с CSS селекторами. К сожалению, проблема остается актуальной в таких браузерах как IE8 и более ранних версиях. Хорошей практикой является повторное использование объектов jQuery, предварительно сохранив их в переменную.

html
```
<ul id="pancakes">
  <li>first</li>
  <li>second</li>
  <li>third</li>
  <li>fourth</li>
  <li>fifth</li>
</ul>
```

js
```
// Плохой способ:
// $('#pancakes li').eq(0).remove();
// $('#pancakes li').eq(1).remove();
// $('#pancakes li').eq(2).remove();

// Хороший:
var pancakes = $('#pancakes li');
pancakes.eq(0).remove();
pancakes.eq(1).remove();
pancakes.eq(2).remove();

// Альтернативный:
// pancakes.eq(0).remove().end()
// .eq(1).remove().end()
// .eq(2).remove().end();
```

Это не только увеличивает производительность вашего приложения, но также делает ваш код более понятным и поддерживаемым.



## 20. Определяйте повторяющуюся функцию только один раз

Еще один оптимизационный момент, который вы должны знать, заключается в том, чтобы определять функции-слушатели до того, как привязывать их к нескольким элементам, а затем передавать их в качестве переменных.

html
```
<button id="menuButton">Show Menu!</button>
<a href="#" id="menuLink">Show Menu!</a>
```

js Пример 1
```
// Это приводит к множественному копированию callback-функции в памяти
$('#menuButton, #menuLink').click(function() {
  // ...
});
```

js Пример 2
```
// Так лучше:
function showMenu(){
  alert('Showing menu!');
  // Тело слушателя
}
$('#menuButton').click(showMenu);
$('#menuLink').click(showMenu);
```

Если вы определяете callback-функцию так, как показано в первом примере и jQuery объект содержит больше одного элемента, копии функции сохранятся в памяти для каждого элемента коллекции.



## 21. Обрабатывайте jQuery объекты как массивы

Возможно вы не знали, но использование элегантного jQuery метод `each` не самое лучшее решение, если вы думаете о производительности. Этот трюк позволяет перебирать объект jQuery намного быстрее. Просто воспринимайте его как самый обычный массив. У объекта есть свойство `length` и каждый элемент имеет свой индекс.

html
```
<ul id="testList">
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <!-- и так далее -->
</ul>
```

js
```
var arr = $('li'),
  iterations = 100000;

console.time('Native Loop');
for (var z = 0; z < iterations; z++) {
  var length = arr.length;
  for (var i = 0; i < length; i++) {
    arr[i];
  }
}
console.timeEnd('Native Loop');

console.time('jQuery Each');
for (z = 0; z < iterations; z++) {
  arr.each(function(i, val) {
    this;
  });
}
console.timeEnd('jQuery Each');

Нативный цикл может быть в 5 раз быстрее метода `each()`! Внутри циклов мы не делаем ничего особенного - просто обращаемся к DOM элементам. Если вам потребуется что-то более вычислительно сложное, разница между `$.each()` и `for()` будет менее заметна, так как интерпретатор будет тратить большую часть своего времени на то, что содержится внутри циклов.



## 22. Отделяйте элементы, если производите сложные модификации над ними

Модификация DOM элемента требует перерисовки страницы для каждого изменения стиля, которое может вам дорого стоить. Если вы хотите сэкономить каждую частичку производительности, можете попробовать отделить элемент от страницы на время его интенсивной модификации.

html
```
<div id="elem" style="background:blue"></div>
```

js
```
var i = 0, iterations = 1000;

// Изменяем элемент на месте
var elem = $('#elem');

console.time('In place');
for (i = 0; i < iterations; i++) {
  elem.width(Math.round(100*Math.random()));
  elem.height(Math.round(100*Math.random()));
}
console.timeEnd('In place');

var parent = elem.parent();

// Теперь сначала отделяем его от DOM
console.time('Detached');
elem.detach();
for (i = 0; i < iterations; i++) {
  elem.width(Math.round(100*Math.random()));
  elem.height(Math.round(100*Math.random()));
}
elem.appendTo(parent);
console.timeEnd('Detached');
```

Отделение элементов может ускорить ваш код в два раза. Это касается не только ширины и высоты - изменение любого стиля или содержания вызывает перерисовку элемента или даже целой страницы.



## 23. Не ждите загрузки страницы

Мы привыкли располагать весь наш код внутри обработчика событий `$(document).ready()`. Однако, если у нас тяжелая страница, готовность документа может задержаться. Но существует обходной путь, который улучшает отзывчивость страницы — использование делегирование событий, мы можем привязать событие, даже если страница еще не загружена:

```
// jQuery уже загружен. Прямо сейчас мы можем использовать
// делегирование события, чтобы привязать события
// даже перед $(document).ready():
$(document).on('click', '#clickMe', function() {
  alert('Hey handsome!');
});
$(document).ready(function() {
  // Это то место, куда вы обычно помещаете обработчики
  // но поскольку мы используем делегирование в этом нет нужды.
  // $('#clickMe').click(function() { alert('Hey!'); });
});
```

За пределами `document.ready()` вы можете инициализировать объекты, производить вычисления, запускать Ajax запросы и многое другое.



## 24. Создавайте таблицы стилей, если стилизуете множество элементов

Как мы раньше упоминали, манипуляции с DOM достаточно медленны. Один из способов решить эту проблему в случае, если вам нужно изменить стили — создание таблицы стилей с последующей вставкой ее в документ.

html
```
<ul id="testList">
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <li>Item</li>
  <!-- и так далее -->
</ul>
```

js
```
var style = $('<style/>');
// Добавляем стили в качестве содержимого тега:
style.text('#testList li { color: red; font-size: 20px; }');
// Располагаем их в самом начале body, чтобы они подействовали на элементы
style.prependTo('body');
```

Это быстрее, потому что браузеры определяют, когда нужно перерисовать DOM и сразу обновляют все элементы. А обходя все элементы в цикле и обновляя их стили, вы просто не сможете получить подобного результата.



# III. События

Простая реализация прослушки событий — еще одна причина, по которой jQuery является одной из самых популярных JavaScript библиотек. Ни одно современное веб-приложение не обходится без этого инструмента. В этой главе я представлю вам ряд советов и трюков, как лучше использовать функционал jQuery для решения реальных проблем, с которыми вы можете столкнуться, и сохранить при этом ваше время.